/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of GBookmarkFile.xs. Do not edit this file, edit GBookmarkFile.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "GBookmarkFile.xs"
/*
 * Copyright (C) 2006,2012 by the gtk2-perl team (see the file AUTHORS for
 * the full list)
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

#include "gperl.h"

SV *
newSVGBookmarkFile (GBookmarkFile * bookmark_file)
{
	HV * bookmark = newHV ();
	SV * sv;
	HV * stash;

	/* tie the key_file to our hash using some magic */
	_gperl_attach_mg ((SV *) bookmark, bookmark_file);

	/* wrap it, bless it, ship it. */
	sv = newRV_noinc ((SV *) bookmark);

	stash = gv_stashpv ("Glib::BookmarkFile", TRUE);
	sv_bless (sv, stash);

	return sv;
}

GBookmarkFile *
SvGBookmarkFile (SV * sv)
{
	MAGIC * mg;
	if (!gperl_sv_is_ref (sv) || !(mg = _gperl_find_mg (SvRV (sv))))
		return NULL;
	return (GBookmarkFile *) mg->mg_ptr;
}


#line 62 "GBookmarkFile.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 204 "GBookmarkFile.c"

XS_EUPXS(XS_Glib__BookmarkFile_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bookmark_file");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
#line 119 "GBookmarkFile.xs"
        g_bookmark_file_free (bookmark_file);
#line 217 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "class");
    {
	GBookmarkFile *	RETVAL;

	RETVAL = g_bookmark_file_new(/* void */);
	ST(0) = newSVGBookmarkFile (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_load_from_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_load_from_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, file");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	GPerlFilename_const	file = (GPerlFilename_const) gperl_filename_from_sv (ST(1))
;
#line 137 "GBookmarkFile.xs"
        GError *err = NULL;
#line 253 "GBookmarkFile.c"
#line 139 "GBookmarkFile.xs"
        g_bookmark_file_load_from_file (bookmark_file, file, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 258 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_load_from_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_load_from_data)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, buf");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	SV *	buf = ST(1)
;
#line 151 "GBookmarkFile.xs"
    	STRLEN length;
	GError *err = NULL;
	const gchar *data = (const gchar *) SvPV (buf, length);
#line 279 "GBookmarkFile.c"
#line 155 "GBookmarkFile.xs"
        g_bookmark_file_load_from_data (bookmark_file, data, length, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 284 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_load_from_data_dirs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_load_from_data_dirs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	GPerlFilename_const	file = (GPerlFilename_const) gperl_filename_from_sv (ST(1))
;
#line 170 "GBookmarkFile.xs"
        GError *err = NULL;
	gchar *full_path;
#line 306 "GBookmarkFile.c"
#line 173 "GBookmarkFile.xs"
        g_bookmark_file_load_from_data_dirs (bookmark_file, file,
					     &full_path,
					     &err);
	if (err)
		gperl_croak_gerror (NULL, err);
	if (full_path) {
		XPUSHs (sv_2mortal (newSVGChar (full_path)));
		g_free (full_path);
	}
#line 317 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_to_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_to_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bookmark_file");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
#line 190 "GBookmarkFile.xs"
     	GError *err = NULL;
	gsize len;
#line 336 "GBookmarkFile.c"
	gchar_own *	RETVAL;
#line 193 "GBookmarkFile.xs"
        RETVAL = g_bookmark_file_to_data (bookmark_file, &len, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 342 "GBookmarkFile.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_to_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_to_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, file");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	GPerlFilename_const	file = (GPerlFilename_const) gperl_filename_from_sv (ST(1))
;
#line 209 "GBookmarkFile.xs"
        GError *err = NULL;
#line 368 "GBookmarkFile.c"
#line 211 "GBookmarkFile.xs"
    	g_bookmark_file_to_file (bookmark_file, file, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 373 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_has_item); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_has_item)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
	gboolean	RETVAL;
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	RETVAL = g_bookmark_file_has_item(bookmark_file, uri);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_remove_item); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_remove_item)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
#line 227 "GBookmarkFile.xs"
        GError *err = NULL;
#line 413 "GBookmarkFile.c"
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 229 "GBookmarkFile.xs"
        g_bookmark_file_remove_item (bookmark_file, uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 426 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_move_item); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_move_item)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, old_uri, new_uri");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	old_uri;
	const gchar_ornull *	new_uri;
#line 244 "GBookmarkFile.xs"
        GError *err = NULL;
#line 445 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	old_uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(2))) {
		sv_utf8_upgrade (ST(2));
		new_uri = (const gchar_ornull *)SvPV_nolen (ST(2));
	} else {
		new_uri = NULL;
	}
;
#line 246 "GBookmarkFile.xs"
        g_bookmark_file_move_item (bookmark_file, old_uri, new_uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 464 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bookmark_file");
    {
	gint	RETVAL;
	dXSTARG;
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;

	RETVAL = g_bookmark_file_get_size(bookmark_file);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_get_uris); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_uris)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bookmark_file");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
#line 263 "GBookmarkFile.xs"
    	gchar **uris;
	gsize len, i;
#line 503 "GBookmarkFile.c"
#line 266 "GBookmarkFile.xs"
    	uris = g_bookmark_file_get_uris (bookmark_file, &len);
	if (len != 0) {
		for (i = 0; i < len; i++) {
			if (uris[i])
				XPUSHs (sv_2mortal (newSVGChar (uris[i])));
		}
	}
	g_strfreev (uris);
#line 513 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_set_title); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_title)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, title");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	title;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	title = (const gchar *)SvPV_nolen (ST(2))
;

	g_bookmark_file_set_title(bookmark_file, uri, title);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_title); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_title)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
#line 291 "GBookmarkFile.xs"
    	GError *err = NULL;
#line 560 "GBookmarkFile.c"
	gchar_own *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 293 "GBookmarkFile.xs"
    	RETVAL = g_bookmark_file_get_title (bookmark_file, uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 571 "GBookmarkFile.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_set_description); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_description)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, description");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	description;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	description = (const gchar *)SvPV_nolen (ST(2))
;

	g_bookmark_file_set_description(bookmark_file, uri, description);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_description); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_description)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
#line 315 "GBookmarkFile.xs"
    	GError *err = NULL;
#line 624 "GBookmarkFile.c"
	gchar_own *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 317 "GBookmarkFile.xs"
    	RETVAL = g_bookmark_file_get_description (bookmark_file, uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 635 "GBookmarkFile.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_set_mime_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_mime_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, mime_type");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	mime_type;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	mime_type = (const gchar *)SvPV_nolen (ST(2))
;

	g_bookmark_file_set_mime_type(bookmark_file, uri, mime_type);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_mime_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_mime_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
#line 338 "GBookmarkFile.xs"
    	GError *err = NULL;
#line 688 "GBookmarkFile.c"
	gchar_own *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 340 "GBookmarkFile.xs"
    	RETVAL = g_bookmark_file_get_mime_type (bookmark_file, uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 699 "GBookmarkFile.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_set_groups); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_groups)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "bookmark_file, uri, ...");
    {
#line 355 "GBookmarkFile.xs"
        gchar **groups;
	gsize groups_len;
	int i;
#line 723 "GBookmarkFile.c"
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 359 "GBookmarkFile.xs"
        groups_len = (gsize) (items - 2);
	groups = g_new0 (gchar *, groups_len + 1);
	for (i = 2; i < items; i++)
		groups[i - 2] = SvPV_nolen (ST (i));
	g_bookmark_file_set_groups (bookmark_file, uri,
			            (const gchar **) groups,
				    groups_len);
	g_free (groups);
#line 741 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_add_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_add_group)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, group");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	group;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	group = (const gchar *)SvPV_nolen (ST(2))
;

	g_bookmark_file_add_group(bookmark_file, uri, group);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_has_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_has_group)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, group");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	group;
#line 385 "GBookmarkFile.xs"
        GError *err = NULL;
#line 788 "GBookmarkFile.c"
	gboolean	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	group = (const gchar *)SvPV_nolen (ST(2))
;
#line 387 "GBookmarkFile.xs"
        RETVAL = g_bookmark_file_has_group (bookmark_file, uri, group, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 804 "GBookmarkFile.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_get_groups); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_groups)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 399 "GBookmarkFile.xs"
        GError *err = NULL;
	gchar **groups;
	gsize len, i;
#line 825 "GBookmarkFile.c"
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 403 "GBookmarkFile.xs"
        groups = g_bookmark_file_get_groups (bookmark_file, uri, &len, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
	if (len != 0) {
		for (i = 0; i < len; i++) {
			if (groups[i])
				XPUSHs (sv_2mortal (newSVGChar (groups[i])));
		}
	}
	g_strfreev (groups);
#line 845 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_remove_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_remove_group)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, group");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	group;
#line 424 "GBookmarkFile.xs"
        GError *err = NULL;
#line 865 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	group = (const gchar *)SvPV_nolen (ST(2))
;
#line 426 "GBookmarkFile.xs"
        g_bookmark_file_remove_group (bookmark_file, uri, group, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 880 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_add_application); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_add_application)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "bookmark_file, uri, name, exec");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar_ornull *	name;
	const gchar_ornull *	exec;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(2))) {
		sv_utf8_upgrade (ST(2));
		name = (const gchar_ornull *)SvPV_nolen (ST(2));
	} else {
		name = NULL;
	}
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(3))) {
		sv_utf8_upgrade (ST(3));
		exec = (const gchar_ornull *)SvPV_nolen (ST(3));
	} else {
		exec = NULL;
	}
;

	g_bookmark_file_add_application(bookmark_file, uri, name, exec);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_has_application); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_has_application)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, name");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	name;
#line 470 "GBookmarkFile.xs"
        GError *err = NULL;
#line 941 "GBookmarkFile.c"
	gboolean	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	name = (const gchar *)SvPV_nolen (ST(2))
;
#line 472 "GBookmarkFile.xs"
    	RETVAL = g_bookmark_file_has_application (bookmark_file,
						  uri,
						  name,
						  &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 960 "GBookmarkFile.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_remove_application); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_remove_application)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, name");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	name;
#line 491 "GBookmarkFile.xs"
        GError *err = NULL;
#line 981 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	name = (const gchar *)SvPV_nolen (ST(2))
;
#line 493 "GBookmarkFile.xs"
        g_bookmark_file_remove_application (bookmark_file, uri, name, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 996 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_applications); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_applications)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
#line 507 "GBookmarkFile.xs"
    	gchar **apps;
	gsize len, i;
	GError *err = NULL;
#line 1018 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 511 "GBookmarkFile.xs"
    	apps = g_bookmark_file_get_applications (bookmark_file, uri, &len, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
	if (len != 0) {
		for (i = 0; i < len; i++) {
			if (apps[i])
				XPUSHs (sv_2mortal (newSVGChar (apps[i])));
		}
	}
	g_strfreev (apps);
#line 1035 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_set_app_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_app_info)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "bookmark_file, uri, name, exec, count, stamp");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	name;
	const gchar *	exec;
	gint	count = (gint)SvIV(ST(4))
;
	time_t	stamp = (time_t)SvNV(ST(5))
;
#line 556 "GBookmarkFile.xs"
    	GError *err = NULL;
#line 1060 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	name = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	exec = (const gchar *)SvPV_nolen (ST(3))
;
#line 558 "GBookmarkFile.xs"
    	g_bookmark_file_set_app_info (bookmark_file, uri, name,
				      exec,
				      count,
				      stamp,
				      &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 1084 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_app_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_app_info)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar *	name;
#line 578 "GBookmarkFile.xs"
    	gchar *exec;
	guint count;
	time_t stamp;
        GError *err = NULL;
#line 1108 "GBookmarkFile.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	name = (const gchar *)SvPV_nolen (ST(2))
;
#line 583 "GBookmarkFile.xs"
        g_bookmark_file_get_app_info (bookmark_file, uri, name,
				      &exec,
				      &count,
				      &stamp,
				      &err);
	if (err)
		gperl_croak_gerror (NULL, err);
	EXTEND (SP, 3);
	PUSHs (sv_2mortal (newSVGChar (exec)));
	PUSHs (sv_2mortal (newSViv (count)));
	PUSHs (sv_2mortal (newSViv (stamp)));
	g_free (exec);
#line 1132 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_set_is_private); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_is_private)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, is_private");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	gboolean	is_private = (bool)SvTRUE(ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	g_bookmark_file_set_is_private(bookmark_file, uri, is_private);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_is_private); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_is_private)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
#line 606 "GBookmarkFile.xs"
        GError *err = NULL;
#line 1172 "GBookmarkFile.c"
	gboolean	RETVAL;
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 608 "GBookmarkFile.xs"
    	RETVAL = g_bookmark_file_get_is_private (bookmark_file, uri, &err);
	if (err)
		gperl_croak_gerror (NULL, err);
#line 1186 "GBookmarkFile.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_set_icon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_icon)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "bookmark_file, uri, href, mime_type");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	const gchar_ornull *	href;
	const gchar_ornull *	mime_type;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(2))) {
		sv_utf8_upgrade (ST(2));
		href = (const gchar_ornull *)SvPV_nolen (ST(2));
	} else {
		href = NULL;
	}
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(3))) {
		sv_utf8_upgrade (ST(3));
		mime_type = (const gchar_ornull *)SvPV_nolen (ST(3));
	} else {
		mime_type = NULL;
	}
;

	g_bookmark_file_set_icon(bookmark_file, uri, href, mime_type);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__BookmarkFile_get_icon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_icon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 632 "GBookmarkFile.xs"
        gchar *href, *mime_type;
        GError *err = NULL;
#line 1248 "GBookmarkFile.c"
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 635 "GBookmarkFile.xs"
        g_bookmark_file_get_icon (bookmark_file, uri,
				  &href,
				  &mime_type,
				  &err);
	if (err)
		gperl_croak_gerror (NULL, err);
	EXTEND (SP, 2);
	PUSHs (sv_2mortal (newSVGChar (href)));
	PUSHs (sv_2mortal (newSVGChar (mime_type)));
	g_free (href);
	g_free (mime_type);
#line 1269 "GBookmarkFile.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib__BookmarkFile_get_added); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_get_added)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "bookmark_file, uri");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
#line 670 "GBookmarkFile.xs"
        GError *err = NULL;
#line 1289 "GBookmarkFile.c"
	time_t	RETVAL;
	dXSTARG;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 672 "GBookmarkFile.xs"
        switch (ix) {
	    case 0:
		RETVAL = g_bookmark_file_get_added    (bookmark_file, uri, &err);
		break;
	    case 1:
		RETVAL = g_bookmark_file_get_modified (bookmark_file, uri, &err);
		break;
	    case 2:
		RETVAL = g_bookmark_file_get_visited  (bookmark_file, uri, &err);
		break;
	    default:
		RETVAL = 0;
		g_assert_not_reached ();
		break;
	}
	if (err)
		gperl_croak_gerror (NULL, err);
#line 1315 "GBookmarkFile.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__BookmarkFile_set_added); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__BookmarkFile_set_added)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "bookmark_file, uri, value");
    {
	GBookmarkFile *	bookmark_file = SvGBookmarkFile (ST(0))
;
	const gchar *	uri;
	time_t	value = (time_t)SvNV(ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	uri = (const gchar *)SvPV_nolen (ST(1))
;
#line 716 "GBookmarkFile.xs"
        switch (ix) {
		case 0:
		g_bookmark_file_set_added    (bookmark_file, uri, value); break;
		case 1:
		g_bookmark_file_set_modified (bookmark_file, uri, value); break;
		case 2:
		g_bookmark_file_set_visited  (bookmark_file, uri, value); break;
		default:
			g_assert_not_reached ();
			break;
	}
#line 1352 "GBookmarkFile.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Glib__BookmarkFile); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Glib__BookmarkFile)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("Glib::BookmarkFile::DESTROY", XS_Glib__BookmarkFile_DESTROY, file);
        newXS("Glib::BookmarkFile::new", XS_Glib__BookmarkFile_new, file);
        newXS("Glib::BookmarkFile::load_from_file", XS_Glib__BookmarkFile_load_from_file, file);
        newXS("Glib::BookmarkFile::load_from_data", XS_Glib__BookmarkFile_load_from_data, file);
        newXS("Glib::BookmarkFile::load_from_data_dirs", XS_Glib__BookmarkFile_load_from_data_dirs, file);
        newXS("Glib::BookmarkFile::to_data", XS_Glib__BookmarkFile_to_data, file);
        newXS("Glib::BookmarkFile::to_file", XS_Glib__BookmarkFile_to_file, file);
        newXS("Glib::BookmarkFile::has_item", XS_Glib__BookmarkFile_has_item, file);
        newXS("Glib::BookmarkFile::remove_item", XS_Glib__BookmarkFile_remove_item, file);
        newXS("Glib::BookmarkFile::move_item", XS_Glib__BookmarkFile_move_item, file);
        newXS("Glib::BookmarkFile::get_size", XS_Glib__BookmarkFile_get_size, file);
        newXS("Glib::BookmarkFile::get_uris", XS_Glib__BookmarkFile_get_uris, file);
        newXS("Glib::BookmarkFile::set_title", XS_Glib__BookmarkFile_set_title, file);
        newXS("Glib::BookmarkFile::get_title", XS_Glib__BookmarkFile_get_title, file);
        newXS("Glib::BookmarkFile::set_description", XS_Glib__BookmarkFile_set_description, file);
        newXS("Glib::BookmarkFile::get_description", XS_Glib__BookmarkFile_get_description, file);
        newXS("Glib::BookmarkFile::set_mime_type", XS_Glib__BookmarkFile_set_mime_type, file);
        newXS("Glib::BookmarkFile::get_mime_type", XS_Glib__BookmarkFile_get_mime_type, file);
        newXS("Glib::BookmarkFile::set_groups", XS_Glib__BookmarkFile_set_groups, file);
        newXS("Glib::BookmarkFile::add_group", XS_Glib__BookmarkFile_add_group, file);
        newXS("Glib::BookmarkFile::has_group", XS_Glib__BookmarkFile_has_group, file);
        newXS("Glib::BookmarkFile::get_groups", XS_Glib__BookmarkFile_get_groups, file);
        newXS("Glib::BookmarkFile::remove_group", XS_Glib__BookmarkFile_remove_group, file);
        newXS("Glib::BookmarkFile::add_application", XS_Glib__BookmarkFile_add_application, file);
        newXS("Glib::BookmarkFile::has_application", XS_Glib__BookmarkFile_has_application, file);
        newXS("Glib::BookmarkFile::remove_application", XS_Glib__BookmarkFile_remove_application, file);
        newXS("Glib::BookmarkFile::get_applications", XS_Glib__BookmarkFile_get_applications, file);
        newXS("Glib::BookmarkFile::set_app_info", XS_Glib__BookmarkFile_set_app_info, file);
        newXS("Glib::BookmarkFile::get_app_info", XS_Glib__BookmarkFile_get_app_info, file);
        newXS("Glib::BookmarkFile::set_is_private", XS_Glib__BookmarkFile_set_is_private, file);
        newXS("Glib::BookmarkFile::get_is_private", XS_Glib__BookmarkFile_get_is_private, file);
        newXS("Glib::BookmarkFile::set_icon", XS_Glib__BookmarkFile_set_icon, file);
        newXS("Glib::BookmarkFile::get_icon", XS_Glib__BookmarkFile_get_icon, file);
        cv = newXS("Glib::BookmarkFile::get_visited", XS_Glib__BookmarkFile_get_added, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::BookmarkFile::get_modified", XS_Glib__BookmarkFile_get_added, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::BookmarkFile::get_added", XS_Glib__BookmarkFile_get_added, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::BookmarkFile::set_visited", XS_Glib__BookmarkFile_set_added, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::BookmarkFile::set_added", XS_Glib__BookmarkFile_set_added, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::BookmarkFile::set_modified", XS_Glib__BookmarkFile_set_added, file);
        XSANY.any_i32 = 1;
    }
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

