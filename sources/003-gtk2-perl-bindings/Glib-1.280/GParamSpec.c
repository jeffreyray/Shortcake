/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of GParamSpec.xs. Do not edit this file, edit GParamSpec.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "GParamSpec.xs"
/*
 * Copyright (C) 2003-2004, 2010 by the gtk2-perl team (see the file AUTHORS for
 * the full list)
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * $Id$
 */

#include "gperl.h"
#include "gperl-private.h" /* for _gperl_sv_from_value_internal() */

/*
 * this isn't already done for us.  :-(
 *
 * interestingly, the obvious G_TYPE_PARAM_FLAGS is taken by the 
 * GParamSpecFlags.
 */

static GType
g_param_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      {G_PARAM_READABLE,       "G_PARAM_READABLE",       "readable"},
      {G_PARAM_WRITABLE,       "G_PARAM_WRITABLE",       "writable"},
      {G_PARAM_CONSTRUCT,      "G_PARAM_CONSTRUCT",      "construct"},
      {G_PARAM_CONSTRUCT_ONLY, "G_PARAM_CONSTRUCT_ONLY", "construct-only"},
      {G_PARAM_LAX_VALIDATION, "G_PARAM_LAX_VALIDATION", "lax-validation"},
      {G_PARAM_PRIVATE,        "G_PARAM_PRIVATE",        "private"},
      {0, NULL, NULL}
    };
    etype = g_flags_register_static ("GPerlParamFlags", values);
  }
  return etype;
}


SV *
newSVGParamFlags (GParamFlags flags)
{
	return gperl_convert_back_flags (g_param_flags_get_type (), flags);
}

GParamFlags
SvGParamFlags (SV * sv)
{
	return gperl_convert_flags (g_param_flags_get_type (), sv);
}

static GHashTable * param_package_by_type = NULL;

void
gperl_register_param_spec (GType gtype,
                           const char * package)
{
	if (!param_package_by_type) {
		param_package_by_type =
			g_hash_table_new_full (g_direct_hash,
			                       g_direct_equal,
			                       NULL,
			                       g_free);
		g_hash_table_insert (param_package_by_type,
		                     (gpointer) G_TYPE_PARAM,
		                     g_strdup ("Glib::ParamSpec"));
	}
	g_hash_table_insert (param_package_by_type,
	                     (gpointer) gtype,
	                     g_strdup (package));
	gperl_set_isa (package, "Glib::ParamSpec");
}

const char *
gperl_param_spec_package_from_type (GType gtype)
{
	g_return_val_if_fail (param_package_by_type != NULL, NULL);
	return (const char*) g_hash_table_lookup (param_package_by_type,
	                                          (gpointer) gtype);
}

/*
 * reverse lookup for paramspec types will be really rare, so we'll save
 * some storage space by sacrificing traversal time.
 */
struct FindData {
	const char * package;
	GType found_type;
};
#if GLIB_CHECK_VERSION (2, 4, 0)
static gboolean
find_func (gpointer key,
           gpointer value,
           gpointer user_data)
{
	struct FindData * fd = user_data;
	if (g_str_equal ((const char *) value, fd->package)) {
		fd->found_type = (GType) key;
		return TRUE;
	} else 
		return FALSE;
}
#else
static void
find_func (gpointer key,
           gpointer value,
           gpointer user_data)
{
	struct FindData * fd = user_data;
	if (g_str_equal ((const char *) value, fd->package))
		fd->found_type = (GType) key;
}
#endif

GType
gperl_param_spec_type_from_package (const char * package)
{
	struct FindData fd;
	fd.package = package;
	fd.found_type = 0;
	g_return_val_if_fail (param_package_by_type != NULL, 0);
#if GLIB_CHECK_VERSION (2, 4, 0)
	g_hash_table_find (param_package_by_type, find_func, (gpointer) &fd);
#else
	g_hash_table_foreach (param_package_by_type, find_func, (gpointer) &fd);
#endif
	return fd.found_type;
}

SV *
newSVGParamSpec (GParamSpec * pspec)
{
	const gchar * pv;
	HV * property;
	SV * sv;
	HV * stash;
	const char * package;

	if (!pspec)
		return &PL_sv_undef;

	g_param_spec_ref (pspec);
	g_param_spec_sink (pspec);

	property = newHV ();
	_gperl_attach_mg ((SV*)property, pspec);


	/* for hysterical raisins (backward compatibility with the old
	 * versions which did not use the same C-to-Perl mapping for the
	 * paramspec list returned from Glib::Object::list_properties())
	 * we store a few select keys in the hash directly.
	 */
	gperl_hv_take_sv_s (property, "name",
	                    newSVpv (g_param_spec_get_name (pspec), 0));

	/* map type names to package names, if possible */
	pv = gperl_package_from_type (pspec->value_type);
	if (!pv) pv = g_type_name (pspec->value_type);
	gperl_hv_take_sv_s (property, "type", newSVpv (pv, 0));

	pv = gperl_package_from_type (pspec->owner_type);
	if (!pv)
		pv = g_type_name (pspec->owner_type);
	if (pv)
		gperl_hv_take_sv_s (property, "owner_type", newSVpv (pv, 0));

	pv = g_param_spec_get_blurb (pspec);
	if (pv) gperl_hv_take_sv_s (property, "descr", newSVpv (pv, 0));
	gperl_hv_take_sv_s (property, "flags", newSVGParamFlags (pspec->flags));

	/* wrap it, bless it, ship it. */
	sv = newRV_noinc ((SV*)property);

	package = gperl_param_spec_package_from_type
					(G_PARAM_SPEC_TYPE (pspec));
	if (!package) {
		package = "Glib::ParamSpec";
		warn ("unhandled paramspec type %s, falling back to %s",
		      G_PARAM_SPEC_TYPE_NAME (pspec), package);
	}

	stash = gv_stashpv (package, TRUE);

	sv_bless (sv, stash);

	return sv;
}

GParamSpec *
SvGParamSpec (SV * sv)
{
	MAGIC * mg;
	if (!gperl_sv_is_ref (sv) || !(mg = _gperl_find_mg (SvRV (sv))))
		return NULL;
	return (GParamSpec*) mg->mg_ptr;
}


#line 222 "GParamSpec.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 364 "GParamSpec.c"

XS_EUPXS(XS_Glib__ParamSpec_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 217 "GParamSpec.xs"
	g_param_spec_unref (pspec);
#line 377 "GParamSpec.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Glib__ParamSpec_get_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	SV *	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 287 "GParamSpec.xs"
        char *c;
        RETVAL = newSVpv (g_param_spec_get_name (pspec), 0);
        for (c = SvPV_nolen (RETVAL); c <= SvEND (RETVAL); c++)
                if (*c == '-')
                        *c = '_';
#line 399 "GParamSpec.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_get_nick); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_nick)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	const gchar *	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;

	RETVAL = g_param_spec_get_nick(pspec);
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_get_blurb); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_blurb)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	const gchar *	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;

	RETVAL = g_param_spec_get_blurb(pspec);
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_IV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_IV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 8)
       croak_xs_usage(cv,  "class, name, nick, blurb, minimum, maximum, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	IV	minimum = (IV)SvIV(ST(4))
;
	IV	maximum = (IV)SvIV(ST(5))
;
	IV	default_value = (IV)SvIV(ST(6))
;
	GParamFlags	flags = SvGParamFlags (ST(7))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 328 "GParamSpec.xs"
	RETVAL = NULL;
    	switch (ix) {
	    case 1:
		RETVAL = g_param_spec_char (name, nick, blurb,
		                            (char)minimum, (char)maximum,
		                            (char)default_value, flags);
		break;
	    case 2:
		RETVAL = g_param_spec_int (name, nick, blurb,
		                           minimum, maximum, default_value,
		                           flags);
		break;
	    case 0:
	    case 3:
		RETVAL = g_param_spec_long (name, nick, blurb,
		                            minimum, maximum, default_value,
		                            flags);
		break;
	}
#line 504 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_int64); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_int64)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "class, name, nick, blurb, minimum, maximum, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	gint64	minimum = SvGInt64 (ST(4))
;
	gint64	maximum = SvGInt64 (ST(5))
;
	gint64	default_value = SvGInt64 (ST(6))
;
	GParamFlags	flags = SvGParamFlags (ST(7))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	RETVAL = g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_UV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_UV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 8)
       croak_xs_usage(cv,  "class, name, nick, blurb, minimum, maximum, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	UV	minimum = (UV)SvUV(ST(4))
;
	UV	maximum = (UV)SvUV(ST(5))
;
	UV	default_value = (UV)SvUV(ST(6))
;
	GParamFlags	flags = SvGParamFlags (ST(7))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 381 "GParamSpec.xs"
	RETVAL = NULL;
    	switch (ix) {
	    case 1:
		RETVAL = g_param_spec_uchar (name, nick, blurb,
		                             (guchar)minimum, (guchar)maximum,
		                             (guchar)default_value, flags);
		break;
	    case 2:
		RETVAL = g_param_spec_uint (name, nick, blurb,
		                            minimum, maximum, default_value,
		                            flags);
		break;
	    case 0:
	    case 3:
		RETVAL = g_param_spec_ulong (name, nick, blurb,
		                             minimum, maximum, default_value,
		                             flags);
		break;
	}
#line 610 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_uint64); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_uint64)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "class, name, nick, blurb, minimum, maximum, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	guint64	minimum = SvGUInt64 (ST(4))
;
	guint64	maximum = SvGUInt64 (ST(5))
;
	guint64	default_value = SvGUInt64 (ST(6))
;
	GParamFlags	flags = SvGParamFlags (ST(7))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	RETVAL = g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_boolean)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "class, name, nick, blurb, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	gboolean	default_value = (bool)SvTRUE(ST(4))
;
	GParamFlags	flags = SvGParamFlags (ST(5))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	RETVAL = g_param_spec_boolean(name, nick, blurb, default_value, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_unichar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_unichar)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "class, name, nick, blurb, default_value, flags");
    {
	GParamSpec *	RETVAL;
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	gunichar	default_value = g_utf8_get_char (SvGChar (ST(4)))
;
	GParamFlags	flags = SvGParamFlags (ST(5))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	RETVAL = g_param_spec_unichar(name, nick, blurb, default_value, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_enum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_enum)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "class, name, nick, blurb, enum_type, default_value, flags");
    {
#line 438 "GParamSpec.xs"
	GType gtype;
#line 748 "GParamSpec.c"
	GParamSpec *	RETVAL;
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	const char *	enum_type = (const char *)SvPV_nolen(ST(4))
;
	SV *	default_value = ST(5)
;
	GParamFlags	flags = SvGParamFlags (ST(6))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 440 "GParamSpec.xs"
	gtype = gperl_fundamental_type_from_package (enum_type);
	if (!gtype)
		croak ("package %s is not registered as an enum type",
		       enum_type);
	RETVAL = g_param_spec_enum (name, nick, blurb, gtype,
	                            gperl_convert_enum (gtype, default_value),
	                            flags);
#line 782 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_flags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_flags)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "class, name, nick, blurb, flags_type, default_value, flags");
    {
#line 454 "GParamSpec.xs"
	GType gtype;
#line 799 "GParamSpec.c"
	GParamSpec *	RETVAL;
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	const char *	flags_type = (const char *)SvPV_nolen(ST(4))
;
	SV *	default_value = ST(5)
;
	GParamFlags	flags = SvGParamFlags (ST(6))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 456 "GParamSpec.xs"
	gtype = gperl_fundamental_type_from_package (flags_type);
	if (!gtype)
		croak ("package %s is not registered as an flags type",
		       flags_type);
	RETVAL = g_param_spec_flags (name, nick, blurb, gtype,
	                             gperl_convert_flags (gtype, default_value),
	                             flags);
#line 833 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_double); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_double)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 8)
       croak_xs_usage(cv,  "class, name, nick, blurb, minimum, maximum, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	double	minimum = (double)SvNV(ST(4))
;
	double	maximum = (double)SvNV(ST(5))
;
	double	default_value = (double)SvNV(ST(6))
;
	GParamFlags	flags = SvGParamFlags (ST(7))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 481 "GParamSpec.xs"
	if (ix == 1)
		RETVAL = g_param_spec_float (name, nick, blurb,
		                             (float)minimum, (float)maximum,
					     (float)default_value, flags);
	else
		RETVAL = g_param_spec_double (name, nick, blurb,
		                              minimum, maximum, default_value,
					      flags);
#line 885 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_string)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "class, name, nick, blurb, default_value, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	const gchar_ornull *	default_value;
	GParamFlags	flags = SvGParamFlags (ST(5))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(4))) {
		sv_utf8_upgrade (ST(4));
		default_value = (const gchar_ornull *)SvPV_nolen (ST(4));
	} else {
		default_value = NULL;
	}
;

	RETVAL = g_param_spec_string(name, nick, blurb, default_value, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_param_spec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_param_spec)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 6)
       croak_xs_usage(cv,  "class, name, nick, blurb, package, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	const char *	package = (const char *)SvPV_nolen(ST(4))
;
	GParamFlags	flags = SvGParamFlags (ST(5))
;
#line 533 "GParamSpec.xs"
	GType type = 0;
#line 957 "GParamSpec.c"
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 535 "GParamSpec.xs"
	RETVAL = NULL;
	switch (ix) {
	    case 0: type = gperl_param_spec_type_from_package (package); break;
	    case 1: type = gperl_boxed_type_from_package (package); break;
	    case 2: type = gperl_object_type_from_package (package); break;
	}
	if (!type)
		croak ("type %s is not registered with Glib-Perl", package);
	switch (ix) {
	    case 0:
		RETVAL = g_param_spec_param (name, nick, blurb, type, flags);
		break;
	    case 1:
		RETVAL = g_param_spec_boxed (name, nick, blurb, type, flags);
		break;
	    case 2:
		RETVAL = g_param_spec_object (name, nick, blurb, type, flags);
		break;
	}
#line 994 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_scalar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_scalar)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "class, name, nick, blurb, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	GParamFlags	flags = SvGParamFlags (ST(4))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;
#line 574 "GParamSpec.xs"
	RETVAL = g_param_spec_boxed (name, nick, blurb, GPERL_TYPE_SV, flags);
#line 1032 "GParamSpec.c"
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#if GLIB_CHECK_VERSION(2, 4, 0)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Glib__ParamSpec_override); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_override)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "class, name, overridden");
    {
	const gchar *	name;
	GParamSpec *	overridden = SvGParamSpec (ST(2))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	RETVAL = g_param_spec_override(name, overridden);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_get_redirect_target); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_redirect_target)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
	GParamSpec_ornull *	RETVAL;

	RETVAL = g_param_spec_get_redirect_target(pspec);
	ST(0) = newSVGParamSpec_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#if GLIB_CHECK_VERSION(2, 10, 0)
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_Glib__ParamSpec_gtype); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_gtype)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "class, name, nick, blurb, is_a_type, flags");
    {
	const gchar *	name;
	const gchar *	nick;
	const gchar *	blurb;
	const gchar_ornull *	is_a_type;
	GParamFlags	flags = SvGParamFlags (ST(5))
;
	GParamSpec *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	nick = (const gchar *)SvPV_nolen (ST(2))
;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(3));
	blurb = (const gchar *)SvPV_nolen (ST(3))
;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(4))) {
		sv_utf8_upgrade (ST(4));
		is_a_type = (const gchar_ornull *)SvPV_nolen (ST(4));
	} else {
		is_a_type = NULL;
	}
;

	RETVAL = g_param_spec_gtype(name, nick, blurb, is_a_type ? gperl_type_from_package (is_a_type) : G_TYPE_NONE, flags);
	ST(0) = newSVGParamSpec (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_Glib__ParamSpec_get_flags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_flags)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	GParamFlags	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 652 "GParamSpec.xs"
	RETVAL = pspec->flags;
#line 1151 "GParamSpec.c"
	ST(0) = newSVGParamFlags (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_get_value_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_value_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
#line 661 "GParamSpec.xs"
	GType type;
#line 1169 "GParamSpec.c"
	const char *	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 663 "GParamSpec.xs"
	switch (ix) {
	    case 0: type = pspec->value_type; break;
	    case 1: type = pspec->owner_type; break;
	    default: g_assert_not_reached (); type = 0;
	}
	RETVAL = gperl_package_from_type (type);
	if (!RETVAL)
		RETVAL = g_type_name (type);
#line 1183 "GParamSpec.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_get_default_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_get_default_value)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
#line 690 "GParamSpec.xs"
	GValue v = { 0, };
	GType type;
#line 1200 "GParamSpec.c"
	SV *	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 693 "GParamSpec.xs"
	/* crib note: G_PARAM_SPEC_VALUE_TYPE() is suitable for
	   GParamSpecOverride and gives the target's value type */
	type = G_PARAM_SPEC_VALUE_TYPE (pspec);
	g_value_init (&v, type);
	g_param_value_set_default (pspec, &v);

	if (type == G_TYPE_BOOLEAN) {
	  /* For historical compatibility with what Perl-Gtk2 has done in
             the past, return boolSV() style '' or 1 for a G_TYPE_BOOLEAN,
             the same as gboolean typemap output, not the newSViv() style 0
             or 1 which the generic gperl_sv_from_value() would give on
             G_TYPE_BOOLEAN.

             The two falses, '' vs 0, are of course the same in any boolean
             context or arithmetic, but maybe someone has done a string
             compare or something, so keep ''.

             This applies to Glib::Param::Boolean and in the interests of
             consistency also to a Glib::Param::Override targetting a
             boolean, and also to any hypothetical other ParamSpec which had
             value type G_TYPE_BOOLEAN, either a sub-type of
             GParamSpecBoolean or just a completely separate one with
             G_TYPE_BOOLEAN.  */

	  RETVAL = boolSV (g_value_get_boolean (&v));

        } else if (type == G_TYPE_UINT) {
	  /* For historical compatibility with what Perl-Gtk2 has done in
	     the past, return a single-char string for GParamSpecUnichar.
	     The GValue for a GParamSpecUnichar is only a G_TYPE_UINT and
	     gperl_sv_from_value() would give an integer.

	     This applies to Glib::Param::Unichar and in the interests of
	     consistency is applied also to a Glib::Param::Override
	     targetting a unichar, and also to any sub-type of
	     GParamUnichar.

	     As noted in the POD above this is a bit unfortunate, since it
	     means $obj->set_property() can't be simply called with
	     $obj->find_property->get_default_value().  Watch this space for
	     some sort of variation on get_default_value() which can go
	     straight to set_property(), or to values_cmp() against a
	     get_property(), etc. */

	  GParamSpec *ptarget;
#if GLIB_CHECK_VERSION(2, 4, 0)
	  ptarget = g_param_spec_get_redirect_target(pspec);
	  if (! ptarget) { ptarget = pspec; }
#else
	  ptarget = pspec;
#endif
	  if (g_type_is_a (G_PARAM_SPEC_TYPE(ptarget), G_TYPE_PARAM_UNICHAR)) {
	    {
	      gchar temp[6];
	      gint length = g_unichar_to_utf8 (g_value_get_uint(&v), temp);
	      RETVAL = newSVpv (temp, length);
	      SvUTF8_on (RETVAL);
	    }
	  } else {
	    /* a plain uint, not a unichar */
	    goto plain_gvalue;
	  }

	} else {
	plain_gvalue:
	  /* No PUTBACK/SPAGAIN needed here. */
	  RETVAL = gperl_sv_from_value (&v);
	}
	g_value_unset (&v);
#line 1274 "GParamSpec.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_value_validate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_value_validate)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "pspec, value");
    {
#line 782 "GParamSpec.xs"
	GValue v = { 0, };
	GType type;
	int modify, retcount=1;
#line 1293 "GParamSpec.c"
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
	SV *	value = ST(1)
;
#line 786 "GParamSpec.xs"
	type = G_PARAM_SPEC_VALUE_TYPE (pspec);
	g_value_init (&v, type);
	gperl_value_from_sv (&v, value);
	modify = g_param_value_validate (pspec, &v);
	ST(0) = sv_2mortal (boolSV (modify));
	if (GIMME_V == G_ARRAY) {
	    /* If unmodified then can leave ST(1) "value" alone.

	       If modified then expect that g_param_value_validate() will
	       have made a new block of memory owned by the GValue and which
	       will be freed at the g_value_unset().  For that reason ask
	       _gperl_sv_from_value_internal() to "copy_boxed" to grab
	       before it's freed.

	       If g_param_value_validate() says modified but doesn't
	       in fact modify but just leaves the GValue pointing into
	       the input ST(1) "value" then we might prefer not to
	       copy (but instead leave ST(1) as the return).  Believe
	       that shouldn't happen, ie. a value_validate vfunc
	       shouldn't modify the input but rather if modifying
	       something then it will put in new memory.  Or
	       alternately if it doesn't modify anything then it
	       shouldn't say modified.  (The Glib ref manual circa
	       2.27 doesn't have much guidance on this.)  */

	    retcount = 2;
	    if (modify)
		/* No PUTBACK/SPAGAIN needed here. */
		ST(1) = sv_2mortal (_gperl_sv_from_value_internal(&v,TRUE));
	}
	g_value_unset (&v);
	XSRETURN(retcount);
#line 1331 "GParamSpec.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__ParamSpec_values_cmp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__ParamSpec_values_cmp)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "pspec, value1, value2");
    {
#line 827 "GParamSpec.xs"
	GValue v1 = { 0, };
	GValue v2 = { 0, };
	GType type;
#line 1348 "GParamSpec.c"
	int	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
	SV *	value1 = ST(1)
;
	SV *	value2 = ST(2)
;
#line 831 "GParamSpec.xs"
	type = G_PARAM_SPEC_VALUE_TYPE (pspec);
	g_value_init (&v1, type);
	g_value_init (&v2, type);
	gperl_value_from_sv (&v1, value1);
	gperl_value_from_sv (&v2, value2);
	RETVAL = g_param_values_cmp (pspec, &v1, &v2);
	g_value_unset (&v1);
	g_value_unset (&v2);
#line 1366 "GParamSpec.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Char_get_minimum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Char_get_minimum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	IV	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 885 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_CHAR (pspec)->minimum; break;
	    case 1: RETVAL = G_PARAM_SPEC_INT (pspec)->minimum; break;
	    case 2: RETVAL = G_PARAM_SPEC_LONG (pspec)->minimum; break;
	    default: g_assert_not_reached (); RETVAL = 0;
	}
#line 1392 "GParamSpec.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Char_get_maximum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Char_get_maximum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	IV	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 907 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_CHAR (pspec)->maximum; break;
	    case 1: RETVAL = G_PARAM_SPEC_INT (pspec)->maximum; break;
	    case 2: RETVAL = G_PARAM_SPEC_LONG (pspec)->maximum; break;
	    default: g_assert_not_reached (); RETVAL = 0;
	}
#line 1418 "GParamSpec.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__UChar_get_minimum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__UChar_get_minimum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	UV	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 959 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_UCHAR (pspec)->minimum; break;
	    case 1: RETVAL = G_PARAM_SPEC_UINT (pspec)->minimum; break;
	    case 2: RETVAL = G_PARAM_SPEC_ULONG (pspec)->minimum; break;
	    default: g_assert_not_reached (); RETVAL = 0;
	}
#line 1444 "GParamSpec.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__UChar_get_maximum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__UChar_get_maximum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	UV	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 981 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_UCHAR (pspec)->maximum; break;
	    case 1: RETVAL = G_PARAM_SPEC_UINT (pspec)->maximum; break;
	    case 2: RETVAL = G_PARAM_SPEC_ULONG (pspec)->maximum; break;
	    default: g_assert_not_reached (); RETVAL = 0;
	}
#line 1470 "GParamSpec.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Int64_get_minimum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Int64_get_minimum)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	gint64	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1006 "GParamSpec.xs"
	RETVAL = G_PARAM_SPEC_INT64 (pspec)->minimum;
#line 1489 "GParamSpec.c"
	ST(0) = newSVGInt64 (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Int64_get_maximum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Int64_get_maximum)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	gint64	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1013 "GParamSpec.xs"
	RETVAL = G_PARAM_SPEC_INT64 (pspec)->maximum;
#line 1509 "GParamSpec.c"
	ST(0) = newSVGInt64 (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__UInt64_get_minimum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__UInt64_get_minimum)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	guint64	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1033 "GParamSpec.xs"
	RETVAL = G_PARAM_SPEC_UINT64 (pspec)->minimum;
#line 1529 "GParamSpec.c"
	ST(0) = newSVGUInt64 (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__UInt64_get_maximum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__UInt64_get_maximum)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	guint64	RETVAL;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1040 "GParamSpec.xs"
	RETVAL = G_PARAM_SPEC_UINT64 (pspec)->maximum;
#line 1549 "GParamSpec.c"
	ST(0) = newSVGUInt64 (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Float_get_minimum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Float_get_minimum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	double	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1079 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_FLOAT (pspec)->minimum; break;
	    case 1: RETVAL = G_PARAM_SPEC_DOUBLE (pspec)->minimum; break;
	    default: g_assert_not_reached (); RETVAL = 0.0;
	}
#line 1575 "GParamSpec.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Float_get_maximum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Float_get_maximum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	double	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1096 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_FLOAT (pspec)->maximum; break;
	    case 1: RETVAL = G_PARAM_SPEC_DOUBLE (pspec)->maximum; break;
	    default: g_assert_not_reached (); RETVAL = 0.0;
	}
#line 1600 "GParamSpec.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Float_get_epsilon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Float_get_epsilon)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pspec");
    {
	double	RETVAL;
	dXSTARG;
	GParamSpec *	pspec = SvGParamSpec (ST(0))
;
#line 1112 "GParamSpec.xs"
	switch (ix) {
	    case 0: RETVAL = G_PARAM_SPEC_FLOAT (pspec)->epsilon; break;
	    case 1: RETVAL = G_PARAM_SPEC_DOUBLE (pspec)->epsilon; break;
	    default: g_assert_not_reached (); RETVAL = 0.0;
	}
#line 1625 "GParamSpec.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Enum_get_enum_class); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Enum_get_enum_class)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec_enum");
    {
	const char *	RETVAL;
	dXSTARG;
	GParamSpec *	pspec_enum = SvGParamSpec (ST(0))
;
#line 1128 "GParamSpec.xs"
	RETVAL = gperl_fundamental_package_from_type
			(G_ENUM_CLASS_TYPE
				(G_PARAM_SPEC_ENUM (pspec_enum)->enum_class));
#line 1647 "GParamSpec.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib__Param__Flags_get_flags_class); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__Flags_get_flags_class)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec_flags");
    {
	const char *	RETVAL;
	dXSTARG;
	GParamSpec *	pspec_flags = SvGParamSpec (ST(0))
;
#line 1142 "GParamSpec.xs"
	RETVAL = gperl_fundamental_package_from_type
			(G_FLAGS_CLASS_TYPE
				(G_PARAM_SPEC_FLAGS (pspec_flags)->flags_class));
#line 1669 "GParamSpec.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#if GLIB_CHECK_VERSION(2, 10, 0)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_Glib__Param__GType_get_is_a_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib__Param__GType_get_is_a_type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pspec_gtype");
    {
	const gchar_ornull *	RETVAL;
	GParamSpec *	pspec_gtype = SvGParamSpec (ST(0))
;
#line 1171 "GParamSpec.xs"
	GParamSpecGType * p = G_PARAM_SPEC_GTYPE (pspec_gtype);
	RETVAL = p->is_a_type == G_TYPE_NONE
		? NULL
		: gperl_package_from_type (p->is_a_type);
#line 1694 "GParamSpec.c"
	ST(0) = sv_newmortal();
	/* newSVGChar() allows NULL, but T_GCHAR does not. allow NULL. */
	if (RETVAL) {
		sv_setpv ((SV*)ST(0), RETVAL);
		SvUTF8_on (ST(0));
	} else {
		SvSetSV (ST(0), &PL_sv_undef);
	}
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Glib__ParamSpec); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Glib__ParamSpec)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("Glib::ParamSpec::DESTROY", XS_Glib__ParamSpec_DESTROY, file);
        newXS("Glib::ParamSpec::get_name", XS_Glib__ParamSpec_get_name, file);
        newXS("Glib::ParamSpec::get_nick", XS_Glib__ParamSpec_get_nick, file);
        newXS("Glib::ParamSpec::get_blurb", XS_Glib__ParamSpec_get_blurb, file);
        cv = newXS("Glib::ParamSpec::long", XS_Glib__ParamSpec_IV, file);
        XSANY.any_i32 = 3;
        cv = newXS("Glib::ParamSpec::int", XS_Glib__ParamSpec_IV, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::ParamSpec::IV", XS_Glib__ParamSpec_IV, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::ParamSpec::char", XS_Glib__ParamSpec_IV, file);
        XSANY.any_i32 = 1;
        newXS("Glib::ParamSpec::int64", XS_Glib__ParamSpec_int64, file);
        cv = newXS("Glib::ParamSpec::uint", XS_Glib__ParamSpec_UV, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::ParamSpec::uchar", XS_Glib__ParamSpec_UV, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::ParamSpec::ulong", XS_Glib__ParamSpec_UV, file);
        XSANY.any_i32 = 3;
        cv = newXS("Glib::ParamSpec::UV", XS_Glib__ParamSpec_UV, file);
        XSANY.any_i32 = 0;
        newXS("Glib::ParamSpec::uint64", XS_Glib__ParamSpec_uint64, file);
        newXS("Glib::ParamSpec::boolean", XS_Glib__ParamSpec_boolean, file);
        newXS("Glib::ParamSpec::unichar", XS_Glib__ParamSpec_unichar, file);
        newXS("Glib::ParamSpec::enum", XS_Glib__ParamSpec_enum, file);
        newXS("Glib::ParamSpec::flags", XS_Glib__ParamSpec_flags, file);
        cv = newXS("Glib::ParamSpec::float", XS_Glib__ParamSpec_double, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::ParamSpec::double", XS_Glib__ParamSpec_double, file);
        XSANY.any_i32 = 0;
        newXS("Glib::ParamSpec::string", XS_Glib__ParamSpec_string, file);
        cv = newXS("Glib::ParamSpec::object", XS_Glib__ParamSpec_param_spec, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::ParamSpec::param_spec", XS_Glib__ParamSpec_param_spec, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::ParamSpec::boxed", XS_Glib__ParamSpec_param_spec, file);
        XSANY.any_i32 = 1;
        newXS("Glib::ParamSpec::scalar", XS_Glib__ParamSpec_scalar, file);
#if XSubPPtmpAAAA
        newXS("Glib::ParamSpec::override", XS_Glib__ParamSpec_override, file);
        newXS("Glib::ParamSpec::get_redirect_target", XS_Glib__ParamSpec_get_redirect_target, file);
#endif
#if XSubPPtmpAAAB
        newXS("Glib::ParamSpec::gtype", XS_Glib__ParamSpec_gtype, file);
#endif
        newXS("Glib::ParamSpec::get_flags", XS_Glib__ParamSpec_get_flags, file);
        cv = newXS("Glib::ParamSpec::get_owner_type", XS_Glib__ParamSpec_get_value_type, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::ParamSpec::get_value_type", XS_Glib__ParamSpec_get_value_type, file);
        XSANY.any_i32 = 0;
        newXS("Glib::ParamSpec::get_default_value", XS_Glib__ParamSpec_get_default_value, file);
        newXS("Glib::ParamSpec::value_validate", XS_Glib__ParamSpec_value_validate, file);
        newXS("Glib::ParamSpec::values_cmp", XS_Glib__ParamSpec_values_cmp, file);
        cv = newXS("Glib::Param::Long::get_minimum", XS_Glib__Param__Char_get_minimum, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::Param::Int::get_minimum", XS_Glib__Param__Char_get_minimum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::Char::get_minimum", XS_Glib__Param__Char_get_minimum, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::Long::get_maximum", XS_Glib__Param__Char_get_maximum, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::Param::Int::get_maximum", XS_Glib__Param__Char_get_maximum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::Char::get_maximum", XS_Glib__Param__Char_get_maximum, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::UInt::get_minimum", XS_Glib__Param__UChar_get_minimum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::ULong::get_minimum", XS_Glib__Param__UChar_get_minimum, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::Param::UChar::get_minimum", XS_Glib__Param__UChar_get_minimum, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::ULong::get_maximum", XS_Glib__Param__UChar_get_maximum, file);
        XSANY.any_i32 = 2;
        cv = newXS("Glib::Param::UInt::get_maximum", XS_Glib__Param__UChar_get_maximum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::UChar::get_maximum", XS_Glib__Param__UChar_get_maximum, file);
        XSANY.any_i32 = 0;
        newXS("Glib::Param::Int64::get_minimum", XS_Glib__Param__Int64_get_minimum, file);
        newXS("Glib::Param::Int64::get_maximum", XS_Glib__Param__Int64_get_maximum, file);
        newXS("Glib::Param::UInt64::get_minimum", XS_Glib__Param__UInt64_get_minimum, file);
        newXS("Glib::Param::UInt64::get_maximum", XS_Glib__Param__UInt64_get_maximum, file);
        cv = newXS("Glib::Param::Double::get_minimum", XS_Glib__Param__Float_get_minimum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::Float::get_minimum", XS_Glib__Param__Float_get_minimum, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::Float::get_maximum", XS_Glib__Param__Float_get_maximum, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::Double::get_maximum", XS_Glib__Param__Float_get_maximum, file);
        XSANY.any_i32 = 1;
        cv = newXS("Glib::Param::Float::get_epsilon", XS_Glib__Param__Float_get_epsilon, file);
        XSANY.any_i32 = 0;
        cv = newXS("Glib::Param::Double::get_epsilon", XS_Glib__Param__Float_get_epsilon, file);
        XSANY.any_i32 = 1;
        newXS("Glib::Param::Enum::get_enum_class", XS_Glib__Param__Enum_get_enum_class, file);
        newXS("Glib::Param::Flags::get_flags_class", XS_Glib__Param__Flags_get_flags_class, file);
#if XSubPPtmpAAAC
        newXS("Glib::Param::GType::get_is_a_type", XS_Glib__Param__GType_get_is_a_type, file);
#endif
    }

    /* Initialisation Section */

#line 243 "GParamSpec.xs"
	gperl_register_fundamental (g_param_flags_get_type (),
	                            "Glib::ParamFlags");
	gperl_register_param_spec (G_TYPE_PARAM_CHAR, "Glib::Param::Char");
	gperl_register_param_spec (G_TYPE_PARAM_UCHAR, "Glib::Param::UChar");
	gperl_register_param_spec (G_TYPE_PARAM_UNICHAR, "Glib::Param::Unichar");
	gperl_register_param_spec (G_TYPE_PARAM_BOOLEAN, "Glib::Param::Boolean");
	gperl_register_param_spec (G_TYPE_PARAM_INT, "Glib::Param::Int");
	gperl_register_param_spec (G_TYPE_PARAM_UINT, "Glib::Param::UInt");
	gperl_register_param_spec (G_TYPE_PARAM_LONG, "Glib::Param::Long");
	gperl_register_param_spec (G_TYPE_PARAM_ULONG, "Glib::Param::ULong");
	gperl_register_param_spec (G_TYPE_PARAM_INT64, "Glib::Param::Int64");
	gperl_register_param_spec (G_TYPE_PARAM_UINT64, "Glib::Param::UInt64");
	gperl_register_param_spec (G_TYPE_PARAM_ENUM, "Glib::Param::Enum");
	gperl_register_param_spec (G_TYPE_PARAM_FLAGS, "Glib::Param::Flags");
	gperl_register_param_spec (G_TYPE_PARAM_FLOAT, "Glib::Param::Float");
	gperl_register_param_spec (G_TYPE_PARAM_DOUBLE, "Glib::Param::Double");
	gperl_register_param_spec (G_TYPE_PARAM_STRING, "Glib::Param::String");
	gperl_register_param_spec (G_TYPE_PARAM_PARAM, "Glib::Param::Param");
	gperl_register_param_spec (G_TYPE_PARAM_BOXED, "Glib::Param::Boxed");
	gperl_register_param_spec (G_TYPE_PARAM_POINTER, "Glib::Param::Pointer");
	gperl_register_param_spec (G_TYPE_PARAM_VALUE_ARRAY, "Glib::Param::ValueArray");
	gperl_register_param_spec (G_TYPE_PARAM_OBJECT, "Glib::Param::Object");
#if GLIB_CHECK_VERSION(2,4,0)
	gperl_register_param_spec (G_TYPE_PARAM_OVERRIDE, "Glib::Param::Override");
#endif
#if GLIB_CHECK_VERSION(2,10,0)
	gperl_register_param_spec (G_TYPE_PARAM_GTYPE, "Glib::Param::GType");
#endif

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#line 1869 "GParamSpec.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

