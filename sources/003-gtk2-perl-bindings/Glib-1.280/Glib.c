/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of Glib.xs. Do not edit this file, edit Glib.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Glib.xs"
/*
 * Copyright (C) 2003-2005, 2012 by the gtk2-perl team (see the file AUTHORS
 * for the full list)
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * $Id$
 */

#include "gperl.h"

#if 0
  "Skipped embedded POD."
#endif
#line 51 "Glib.xs"
void
_gperl_call_XS (pTHX_ void (*subaddr) (pTHX_ CV *), CV * cv, SV ** mark)
{
	dSP;
	PUSHMARK (mark);
	(*subaddr) (aTHX_ cv);
	PUTBACK;	/* forget return values */
}


#if 0
  "Skipped embedded POD."
#endif
#line 74 "Glib.xs"
/*
 * taken from pgtk_alloc_temp in Gtk-Perl-0.7008/Gtk/MiscTypes.c
 */
gpointer
gperl_alloc_temp (int nbytes)
{
	dTHR;
	SV * s;

	g_return_val_if_fail (nbytes > 0, NULL);

	s = sv_2mortal (NEWSV (0, nbytes));
	memset (SvPVX (s), 0, nbytes);
	return SvPVX (s);
}

#if 0
  "Skipped embedded POD."
#endif
#line 97 "Glib.xs"
gchar *
gperl_filename_from_sv (SV *sv)
{
        dTHR;

        GError *error = NULL;
        gchar *lname = NULL;
        gsize output_length = 0;
        STRLEN input_length = 0;
        gchar *filename = SvPVutf8 (sv, input_length);

        lname = g_filename_from_utf8 (filename, input_length,
                                      0, &output_length, &error);
        if (!lname)
        	gperl_croak_gerror (NULL, error);

        filename = gperl_alloc_temp (output_length + 1);
        memcpy (filename, lname, output_length);
        g_free (lname);

        return filename;
}

#if 0
  "Skipped embedded POD."
#endif
#line 125 "Glib.xs"
SV *
gperl_sv_from_filename (const gchar *filename)
{
	GError *error = NULL;
        SV *sv;
	gsize len;
        gchar *str = g_filename_to_utf8 (filename, -1, NULL, &len, &error);

        if (!str)
        	gperl_croak_gerror (NULL, error);

        sv = newSVpv (str, len);
        g_free (str);

        SvUTF8_on (sv);
        return sv;
}

#if 0
  "Skipped embedded POD."
#endif
#line 149 "Glib.xs"
gboolean
gperl_str_eq (const char * a,
              const char * b)
{
	while (*a && *b) {
		if (*a == *b ||
		    ((*a == '-' || *a == '_') && (*b == '-' || *b == '_'))) {
			a++;
			b++;
		} else
			return FALSE;
	}
	return *a == *b;
}

#if 0
  "Skipped embedded POD."
#endif
#line 169 "Glib.xs"
guint
gperl_str_hash (gconstpointer key)
{
	const char *p = key;
	guint h = *p;

	if (h)
		for (p += 1; *p != '\0'; p++)
			h = (h << 5) - h + (*p == '-' ? '_' : *p);

	return h;
}

#if 0
  "Skipped embedded POD."
#endif
#line 193 "Glib.xs"
GPerlArgv*
gperl_argv_new ()
{
	AV * ARGV;
	SV * ARGV0;
	int len, i;
	GPerlArgv *pargv;

	pargv = g_new (GPerlArgv, 1);

	/*
	 * heavily borrowed from gtk-perl.
	 *
	 * given the way perl handles the refcounts on SVs and the strings
	 * to which they point, i'm not certain that the g_strdup'ing of
	 * the string values is entirely necessary; however, this compiles
	 * and runs and doesn't appear either to leak or segfault, so i'll
	 * leave it.
	 */

	ARGV = get_av ("ARGV", FALSE);
	ARGV0 = get_sv ("0", FALSE);

	/* 
	 * construct the argv argument... we'll have to prepend @ARGV with $0
	 * to make it look real.  an important wrinkle: client code may strip
	 * arguments it processes without freeing them (argv is statically
	 * allocated in conventional usage).  thus, we need to keep a shadow
	 * copy of argv so we can keep from leaking the stripped strings.
	 */

	len = av_len (ARGV) + 1;

	pargv->argc = len + 1;
	pargv->shadow = g_new0 (char*, pargv->argc);
	pargv->argv = g_new0 (char*, pargv->argc);

	pargv->argv[0] = SvPV_nolen (ARGV0);

	for (i = 0 ; i < len ; i++) {
		SV ** svp = av_fetch (ARGV, i, 0);
		if (svp && gperl_sv_is_defined (*svp))
			pargv->shadow[i] = pargv->argv[i+1]
			                 = g_strdup (SvPV_nolen (*svp));
	}

	return pargv;
}

#if 0
  "Skipped embedded POD."
#endif
#line 247 "Glib.xs"
void
gperl_argv_update (GPerlArgv *pargv)
{
	AV * ARGV;
	int i;

	ARGV = get_av ("ARGV", FALSE);

	/* clear and refill @ARGV with whatever gtk_init didn't steal. */
	av_clear (ARGV);
	for (i = 1 ; i < pargv->argc ; i++)
		av_push (ARGV, newSVpv (pargv->argv[i], 0));
}

#if 0
  "Skipped embedded POD."
#endif
#line 266 "Glib.xs"
void
gperl_argv_free (GPerlArgv *pargv)
{
	g_strfreev (pargv->shadow);
	g_free (pargv->argv);
	g_free (pargv);
}

#if 0
  "Skipped embedded POD."
#endif
#line 281 "Glib.xs"
char *
gperl_format_variable_for_output (SV * sv)
{
	if (sv) {
		/* disambiguate undef */
		if (!gperl_sv_is_defined (sv))
			return SvPV_nolen (sv_2mortal (newSVpv ("undef", 5)));
		/* don't truncate references... */
		if (SvROK (sv))
			return SvPV_nolen (sv);
		/* and quote everything else to disambiguate empty strings
		 * and the like. */
		return form (sv_len (sv) > 20 ? "`%.20s...'" : "`%s'",
		             SvPV_nolen (sv));
	}

	return NULL;
}

#if 0
  "Skipped embedded POD."
#endif
#line 307 "Glib.xs"
gboolean
gperl_sv_is_defined (SV *sv)
{
	/* This is adapted from PP(pp_defined) in perl's pp.c */

	if (!sv || !SvANY(sv))
		return FALSE;

	switch (SvTYPE(sv)) {
	    case SVt_PVAV:
		if (AvMAX(sv) >= 0 || SvGMAGICAL(sv)
		    || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
			return TRUE;
		break;
	    case SVt_PVHV:
		if (HvARRAY(sv) || SvGMAGICAL(sv)
		    || (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
			return TRUE;
		break;
	    case SVt_PVCV:
		if (CvROOT(sv) || CvXSUB(sv))
			return TRUE;
		break;
	    default:
		if (SvGMAGICAL(sv))
			mg_get(sv);
		if (SvOK(sv))
			return TRUE;
	}

	return FALSE;
}

#if 0
  "Skipped embedded POD."
#endif
#line 346 "Glib.xs"
void
gperl_hv_take_sv (HV *hv, const char *key, size_t key_length, SV *sv)
{
	if (!hv_store (hv, key, key_length, sv, 0)) {
		sv_free (sv);
	}
}

#if 0
  "Skipped embedded POD."
#endif
#line 357 "Glib.xs"

/*
 * Thread-safety stuff.
 */
static PerlInterpreter *gperl_master_interp = NULL;
G_LOCK_DEFINE_STATIC (gperl_master_interp);

void
_gperl_set_master_interp (PerlInterpreter *interp)
{
	G_LOCK (gperl_master_interp);
	gperl_master_interp = interp;
	G_UNLOCK (gperl_master_interp);
}

PerlInterpreter *
_gperl_get_master_interp (void)
{
	return gperl_master_interp;
}

#ifndef PERL_IMPLICIT_CONTEXT
/* If perl doesn't use thread-local storage, then we store the main thread's ID
 * at BOOT time so that GClosure.xs can later find out whether we've been
 * called from a foreign thread. */
static GThread *gperl_main_tid = NULL;

static void
_gperl_fetch_main_tid (void)
{
	gperl_main_tid = g_thread_self ();
}

GThread *
_gperl_get_main_tid (void)
{
	return gperl_main_tid;
}
#endif

#line 352 "Glib.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 494 "Glib.c"

XS_EUPXS(XS_Glib_filename_from_unicode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_from_unicode)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "class_or_filename, filename=NULL");
    {
	GPerlFilename_const	class_or_filename = (GPerlFilename_const) gperl_filename_from_sv (ST(0))
;
	GPerlFilename_const	filename;
	const char *	RETVAL;
	dXSTARG;

	if (items < 2)
	    filename = NULL;
	else {
	    filename = (GPerlFilename_const) gperl_filename_from_sv (ST(1))
;
	}
#line 460 "Glib.xs"
	RETVAL = items < 2 ? class_or_filename : filename;
#line 517 "Glib.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib_filename_to_unicode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_to_unicode)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "class_or_filename, filename=NULL");
    {
	GPerlFilename_const	RETVAL;
	const char *	class_or_filename = (const char *)SvPV_nolen(ST(0))
;
	const char *	filename;

	if (items < 2)
	    filename = NULL;
	else {
	    filename = (const char *)SvPV_nolen(ST(1))
;
	}
#line 470 "Glib.xs"
	RETVAL = items < 2 ? class_or_filename : filename;
#line 544 "Glib.c"
	ST(0) = sv_newmortal();
	sv_setsv (ST(0), sv_2mortal (gperl_sv_from_filename (RETVAL)));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib_filename_from_uri); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_from_uri)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 480 "Glib.xs"
	gchar * filename = NULL;
	const char * uri;
	char * hostname = NULL;
	GError * error = NULL;
#line 565 "Glib.c"
#line 485 "Glib.xs"
	/* support multiple call syntaxes. */
	uri = items < 2 ? SvPVutf8_nolen (ST (0)) : SvPVutf8_nolen (ST (1));
	filename = g_filename_from_uri (uri,
	                                GIMME_V == G_ARRAY ? &hostname : NULL, 
	                                &error);
	if (!filename)
		gperl_croak_gerror (NULL, error);
	PUSHs (sv_2mortal (newSVpv (filename, 0)));
	if (GIMME_V == G_ARRAY && hostname) {
		/* The g_filename_from_uri() docs say hostname is utf8,
		 * hence newSVGChar, though as of glib circa 2.16
		 * hostname_validate() only actually allows ascii
		 * alphanumerics, so utf8 doesn't actually come out.
		 */
		XPUSHs (sv_2mortal (newSVGChar (hostname)));
	}
	g_free (filename);
	if (hostname) g_free (hostname);
#line 585 "Glib.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Glib_filename_to_uri); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_to_uri)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 510 "Glib.xs"
	char * filename = NULL;
	char * hostname = NULL;
	GError * error = NULL;
#line 602 "Glib.c"
	gchar_own *	RETVAL;
#line 514 "Glib.xs"
	/* The g_filename_to_uri() docs say hostname is utf8, hence SvGChar,
	 * though as of glib circa 2.16 hostname_validate() only actually
	 * allows ascii alphanumerics, so you can't in fact pass in utf8.
	 */
	if (items == 2) {
		filename = SvPV_nolen (ST (0));
		hostname = gperl_sv_is_defined (ST (1)) ? SvGChar (ST (1)) : NULL;
	} else if (items == 3) {
		filename = SvPV_nolen (ST (1));
		hostname = gperl_sv_is_defined (ST (2)) ? SvGChar (ST (2)) : NULL;
	} else {
		croak ("Usage: Glib::filename_to_uri (filename, hostname)\n"
		       " -or-  Glib->filename_to_uri (filename, hostname)\n"
		       "  wrong number of arguments");
	}
	RETVAL = g_filename_to_uri (filename, hostname, &error);
	if (!RETVAL)
		gperl_croak_gerror (NULL, error);
#line 623 "Glib.c"
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}

#if GLIB_CHECK_VERSION(2, 6, 0)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Glib_filename_display_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_display_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	gchar_own *	RETVAL;
	const char *	filename = (const char *)SvPV_nolen(ST(0))
;

	RETVAL = g_filename_display_name(filename);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Glib_filename_display_basename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Glib_filename_display_basename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	gchar_own *	RETVAL;
	const char *	filename = (const char *)SvPV_nolen(ST(0))
;

	RETVAL = g_filename_display_basename(filename);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Glib); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Glib)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Glib::filename_from_unicode", XS_Glib_filename_from_unicode, file, "$");
        (void)newXSproto_portable("Glib::filename_to_unicode", XS_Glib_filename_to_unicode, file, "$");
        (void)newXSproto_portable("Glib::filename_from_uri", XS_Glib_filename_from_uri, file, "$");
        (void)newXSproto_portable("Glib::filename_to_uri", XS_Glib_filename_to_uri, file, "$$");
#if XSubPPtmpAAAA
        newXS("Glib::filename_display_name", XS_Glib_filename_display_name, file);
        newXS("Glib::filename_display_basename", XS_Glib_filename_display_basename, file);
#endif

    /* Initialisation Section */

#line 400 "Glib.xs"
#if defined(G_THREADS_ENABLED) && !defined(GPERL_DISABLE_THREADSAFE)
	/*warn ("calling g_thread_init (NULL)");*/
	if (!g_thread_supported ())
		g_thread_init (NULL);
#endif
	g_type_init ();
	_gperl_set_master_interp (PERL_GET_INTERP);
#ifndef PERL_IMPLICIT_CONTEXT
	_gperl_fetch_main_tid ();
#endif
	/* boot all in one go.  other modules may not want to do it this
	 * way, if they prefer instead to perform demand loading. */
	GPERL_CALL_BOOT (boot_Glib__Utils);
	GPERL_CALL_BOOT (boot_Glib__Error);
	GPERL_CALL_BOOT (boot_Glib__Log);
	GPERL_CALL_BOOT (boot_Glib__Type);
	GPERL_CALL_BOOT (boot_Glib__Boxed);
	GPERL_CALL_BOOT (boot_Glib__Object);
	GPERL_CALL_BOOT (boot_Glib__Signal);
	GPERL_CALL_BOOT (boot_Glib__Closure);
	GPERL_CALL_BOOT (boot_Glib__MainLoop);
	GPERL_CALL_BOOT (boot_Glib__ParamSpec);
	GPERL_CALL_BOOT (boot_Glib__IO__Channel);
#if GLIB_CHECK_VERSION (2, 6, 0)
	GPERL_CALL_BOOT (boot_Glib__KeyFile);
	GPERL_CALL_BOOT (boot_Glib__Option);
#endif /* GLIB_CHECK_VERSION (2, 6, 0) */
#if GLIB_CHECK_VERSION (2, 12, 0)
	GPERL_CALL_BOOT (boot_Glib__BookmarkFile);
#endif /* GLIB_CHECK_VERSION (2, 12, 0) */
	/* make sure that we're running/linked against a version at least as 
	 * new as we built against, otherwise bad things will happen. */
	if ((((int)glib_major_version) < GLIB_MAJOR_VERSION)
	    ||
	    (glib_major_version == GLIB_MAJOR_VERSION && 
	     ((int)glib_minor_version) < GLIB_MINOR_VERSION)
	    ||
	    (glib_major_version == GLIB_MAJOR_VERSION && 
	     glib_minor_version == GLIB_MINOR_VERSION &&
	     ((int)glib_micro_version) < GLIB_MICRO_VERSION))
		warn ("*** This build of Glib was compiled with glib %d.%d.%d,"
		      " but is currently running with %d.%d.%d, which is too"
		      " old.  We'll continue, but expect problems!\n",
		    GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION,
		    glib_major_version, glib_minor_version, glib_micro_version);

#if XSubPPtmpAAAA
#endif
#line 767 "Glib.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

