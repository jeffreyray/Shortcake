/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of GtkTreeModel.xs. Do not edit this file, edit GtkTreeModel.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "xs\\\\GtkTreeModel.xs"
/*
 * Copyright (c) 2003-2005, 2010, 2012 by the gtk2-perl team (see the file
 * AUTHORS)
 *
 * Licensed under the LGPL, see LICENSE file for more information.
 *
 * $Id$
 */

#include "gtk2perl.h"
#include <gperl_marshal.h>

/* this is just an interface */

static gboolean
gtk2perl_tree_model_foreach_func (GtkTreeModel *model,
                                  GtkTreePath *path,
                                  GtkTreeIter *iter,
                                  gpointer data)
{
	GPerlCallback * callback = (GPerlCallback*)data;
	GValue value = {0,};
	gboolean retval;
	g_value_init (&value, callback->return_type);
	gperl_callback_invoke (callback, &value, model, path, iter);
	retval = g_value_get_boolean (&value);
	g_value_unset (&value);
	return retval;
}

static void
gtk2perl_tree_model_rows_reordered_marshal (GClosure * closure,
                                  	    GValue * return_value,
                                  	    guint n_param_values,
                                  	    const GValue * param_values,
                                  	    gpointer invocation_hint,
                                  	    gpointer marshal_data)
{
	AV * av;
	gint * new_order;
	GtkTreeModel * model;
	GtkTreeIter * iter;
	int n_children, i;
	dGPERL_CLOSURE_MARSHAL_ARGS;

	/* If model is a Perl object then gtk_tree_model_iter_n_children()
	   will call out to ITER_N_CHILDREN in the class, so do that before
	   trying to build the stack here. */
	model = g_value_get_object (param_values);
	iter = g_value_get_boxed (param_values+2);
	n_children = gtk_tree_model_iter_n_children (model, iter);

	GPERL_CLOSURE_MARSHAL_INIT (closure, marshal_data);

	PERL_UNUSED_VAR (return_value);
	PERL_UNUSED_VAR (n_param_values);
	PERL_UNUSED_VAR (invocation_hint);

	ENTER;
	SAVETMPS;

	PUSHMARK (SP);

	/* instance */
	GPERL_CLOSURE_MARSHAL_PUSH_INSTANCE (param_values);

	/* treepath */
	XPUSHs (sv_2mortal (gperl_sv_from_value (param_values+1)));

	/* treeiter */
	XPUSHs (sv_2mortal (gperl_sv_from_value (param_values+2)));

	/* gint * new_order */
	new_order = g_value_get_pointer (param_values+3);
	av = newAV ();
	av_extend (av, n_children-1);
	for (i = 0; i < n_children; i++)
		av_store (av, i, newSViv (new_order[i]));
	XPUSHs (sv_2mortal (newRV_noinc ((SV*)av)));

	GPERL_CLOSURE_MARSHAL_PUSH_DATA;

	PUTBACK;

	GPERL_CLOSURE_MARSHAL_CALL (G_DISCARD);

	/*
	 * clean up
	 */

	FREETMPS;
	LEAVE;
}

/*
 * GtkTreeModelIface
 */

/*
 * Signals - these have class closures, so we can override them "normally"
 *           (for gtk2-perl, that is)
 *
 *	row_changed
 *	row_inserted
 *	row_has_child_toggled
 *	row_deleted
 *	rows_reordered
 */

/*
 * Virtual Table - things for which we must provide overrides
 */

static SV *
find_func (GtkTreeModel * tree_model,
           const char * method_name)
{
	HV * stash = gperl_object_stash_from_type (G_OBJECT_TYPE (tree_model));
	return (SV*) gv_fetchmethod (stash, method_name);
}

#define PREP(model)	\
	dSP;			\
	ENTER;			\
	SAVETMPS;		\
	PUSHMARK (SP);		\
	PUSHs (sv_2mortal (newSVGObject (G_OBJECT (model))));

#define CALL(name, flags)	\
	PUTBACK;			\
	call_method (name, flags);	\
	SPAGAIN;

#define FINISH	\
	PUTBACK;	\
	FREETMPS;	\
	LEAVE;

static GtkTreeModelFlags
gtk2perl_tree_model_get_flags (GtkTreeModel *tree_model)
{
	GtkTreeModelFlags ret;
	PREP (tree_model);
	CALL ("GET_FLAGS", G_SCALAR);
	ret = SvGtkTreeModelFlags (POPs);
	FINISH;
	return ret;
}

static gint
gtk2perl_tree_model_get_n_columns (GtkTreeModel *tree_model)
{
	int ret;
	PREP (tree_model);
	CALL ("GET_N_COLUMNS", G_SCALAR);
	ret = POPi;
	FINISH;
	return ret;
}

static GType
gtk2perl_tree_model_get_column_type (GtkTreeModel *tree_model,
                                     gint          index_)
{
	GType ret;
	SV * svret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (newSViv (index_)));
	CALL ("GET_COLUMN_TYPE", G_SCALAR);
	svret = POPs;
	PUTBACK;
	ret = gperl_type_from_package (SvPV_nolen (svret));
	if (!ret)
		croak ("package %s is not registered with GPerl\n",
		       SvPV_nolen (svret));
	FREETMPS;
	LEAVE;
	return ret;
}

static SV *
sv_from_iter (GtkTreeIter * iter)
{
	AV * av;
	if (!iter)
		return &PL_sv_undef;
	av = newAV ();
	av_push (av, newSVuv (iter->stamp));
	av_push (av, newSViv (PTR2IV (iter->user_data)));
	av_push (av, iter->user_data2 ? newRV (iter->user_data2) : &PL_sv_undef);
	av_push (av, iter->user_data3 ? newRV (iter->user_data3) : &PL_sv_undef);
	return newRV_noinc ((SV*)av);
}

static gboolean
iter_from_sv (GtkTreeIter * iter,
              SV * sv)
{
	/* we allow undef as the sentinel from the perl vfuncs to tell us
	 * to return FALSE from the C vfuncs.  for anything else, it *must*
	 * be an array reference or we croak with an informative message
	 * (since that would be caused by a programming bug). */
	if (gperl_sv_is_defined (sv)) {
		SV ** svp;
		AV * av;
		if (!gperl_sv_is_array_ref (sv))
			croak ("expecting a reference to an ARRAY to describe "
			       "a tree iter, not a %s",
			       sv_reftype (SvRV (sv), 0));
		av = (AV*) SvRV (sv);
		if ((svp = av_fetch (av, 0, FALSE)))
			iter->stamp = SvUV (*svp);

		if ((svp = av_fetch (av, 1, FALSE)) && gperl_sv_is_defined (*svp))
			iter->user_data = INT2PTR (gpointer, SvIV (*svp));
		else
			iter->user_data = NULL;

		if ((svp = av_fetch (av, 2, FALSE)) && gperl_sv_is_ref (*svp))
			iter->user_data2 =  SvRV (*svp);
		else
			iter->user_data2 = NULL;

		if ((svp = av_fetch (av, 3, FALSE)) && gperl_sv_is_ref (*svp))
			iter->user_data3 =  SvRV (*svp);
		else
			iter->user_data3 = NULL;
		return TRUE;
	} else {
		iter->stamp = 0;
		iter->user_data = 0;
		iter->user_data2 = 0;
		iter->user_data3 = 0;
		return FALSE;
	}
}

static gboolean
gtk2perl_tree_model_get_iter (GtkTreeModel *tree_model,
      			      GtkTreeIter  *iter,
      			      GtkTreePath  *path)
{
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (path ? newSVGtkTreePath (path) : &PL_sv_undef));
	CALL ("GET_ITER", G_SCALAR);
	ret = iter_from_sv (iter, POPs);
	FINISH;
	return ret;
}

static GtkTreePath *
gtk2perl_tree_model_get_path (GtkTreeModel *tree_model,
      			      GtkTreeIter  *iter)
{
	GtkTreePath * ret = NULL;
	SV * sv;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (iter)));
	CALL ("GET_PATH", G_SCALAR);
	sv = POPs;
	/* restore the stack before parsing the output, since SvGtkTreePath
	 * might croak.  FREETMPS will destroy the path, though, so we need
	 * to copy it, first. */
	PUTBACK;
	if (gperl_sv_is_defined (sv))
		ret = gtk_tree_path_copy (SvGtkTreePath (sv));
	FREETMPS;
	LEAVE;
	return ret;
}

static void
gtk2perl_tree_model_get_value (GtkTreeModel *tree_model,
      			       GtkTreeIter  *iter,
      			       gint          column,
      			       GValue       *value)
{
	g_value_init (value,
	              gtk2perl_tree_model_get_column_type (tree_model, column));
	{
		PREP (tree_model);
		XPUSHs (sv_2mortal (sv_from_iter (iter)));
		XPUSHs (sv_2mortal (newSViv (column)));
		CALL ("GET_VALUE", G_SCALAR);
		gperl_value_from_sv (value, POPs);
		FINISH;
	}
}

static gboolean
gtk2perl_tree_model_iter_next (GtkTreeModel *tree_model,
      			       GtkTreeIter  *iter)
{
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (iter)));
	CALL ("ITER_NEXT", G_SCALAR);
	ret = iter_from_sv (iter, POPs);
	FINISH;
	return ret;
}

static gboolean
gtk2perl_tree_model_iter_children (GtkTreeModel *tree_model,
                                   GtkTreeIter  *iter,
                                   GtkTreeIter  *parent)
{
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (parent)));
	CALL ("ITER_CHILDREN", G_SCALAR);
	ret = iter_from_sv (iter, POPs);
	FINISH;
	return ret;
}

static gboolean
gtk2perl_tree_model_iter_has_child (GtkTreeModel *tree_model,
                                    GtkTreeIter  *iter)
{
	SV *sv;
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (iter)));
	CALL ("ITER_HAS_CHILD", G_SCALAR);
	sv = POPs;
	ret = sv_2bool (sv);
	FINISH;
	return ret;
}

static gint
gtk2perl_tree_model_iter_n_children (GtkTreeModel *tree_model,
      			    GtkTreeIter  *iter)
{
	gint ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (iter)));
	CALL ("ITER_N_CHILDREN", G_SCALAR);
	ret = POPi;
	FINISH;
	return ret;
}

static gboolean
gtk2perl_tree_model_iter_nth_child (GtkTreeModel *tree_model,
                                    GtkTreeIter  *iter,
                                    GtkTreeIter  *parent,
                                    gint          n)
{
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (parent)));
	XPUSHs (sv_2mortal (newSViv (n)));
	CALL ("ITER_NTH_CHILD", G_SCALAR);
	ret = iter_from_sv (iter, POPs);
	FINISH;
	return ret;
}

static gboolean
gtk2perl_tree_model_iter_parent (GtkTreeModel *tree_model,
      			         GtkTreeIter  *iter,
      			         GtkTreeIter  *child)
{
	gboolean ret;
	PREP (tree_model);
	XPUSHs (sv_2mortal (sv_from_iter (child)));
	CALL ("ITER_PARENT", G_SCALAR);
	ret = iter_from_sv (iter, POPs);
	FINISH;
	return ret;
}

static void
gtk2perl_tree_model_ref_node (GtkTreeModel *tree_model,
                              GtkTreeIter  *iter)
{
	SV * func = find_func (tree_model, "REF_NODE");
	if (func) {
		PREP (tree_model);
		XPUSHs (sv_2mortal (sv_from_iter (iter)));
		PUTBACK;
		call_sv (func, G_VOID|G_DISCARD);
		FINISH;
	}
}

static void
gtk2perl_tree_model_unref_node (GtkTreeModel *tree_model,
                                GtkTreeIter  *iter)
{
	SV * func = find_func (tree_model, "UNREF_NODE");
	if (func) {
		PREP (tree_model);
		XPUSHs (sv_2mortal (sv_from_iter (iter)));
		PUTBACK;
		call_sv (func, G_VOID|G_DISCARD);
		FINISH;
	}
}


static void
gtk2perl_tree_model_init (GtkTreeModelIface * iface)
{
	iface->get_flags       = gtk2perl_tree_model_get_flags;
	iface->get_n_columns   = gtk2perl_tree_model_get_n_columns;
	iface->get_column_type = gtk2perl_tree_model_get_column_type;
	iface->get_iter        = gtk2perl_tree_model_get_iter;
	iface->get_path        = gtk2perl_tree_model_get_path;
	iface->get_value       = gtk2perl_tree_model_get_value;
	iface->iter_next       = gtk2perl_tree_model_iter_next;
	iface->iter_children   = gtk2perl_tree_model_iter_children;
	iface->iter_has_child  = gtk2perl_tree_model_iter_has_child;
	iface->iter_n_children = gtk2perl_tree_model_iter_n_children;
	iface->iter_nth_child  = gtk2perl_tree_model_iter_nth_child;
	iface->iter_parent     = gtk2perl_tree_model_iter_parent;
	iface->ref_node        = gtk2perl_tree_model_ref_node;
	iface->unref_node      = gtk2perl_tree_model_unref_node;
}

#line 434 "xs\\GtkTreeModel.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 576 "xs\\GtkTreeModel.c"

XS_EUPXS(XS_Gtk2__TreeModel__ADD_INTERFACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel__ADD_INTERFACE)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, target_class");
    {
	const char *	target_class = (const char *)SvPV_nolen(ST(1))
;
#line 655 "xs\\\\GtkTreeModel.xs"
    {
	static const GInterfaceInfo iface_info = {
		(GInterfaceInitFunc) gtk2perl_tree_model_init,
		(GInterfaceFinalizeFunc) NULL,
		(gpointer) NULL
	};
	GType gtype = gperl_object_type_from_package (target_class);
	g_type_add_interface_static (gtype, GTK_TYPE_TREE_MODEL, &iface_info);
    }
#line 597 "xs\\GtkTreeModel.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreePath_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_new)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "class, path=NULL");
    {
	const gchar *	path;
	GtkTreePath_own_ornull *	RETVAL;

	if (items < 2)
	    path = NULL;
	else {
	    /* same as SvGChar(), but not in a function */
	    sv_utf8_upgrade (ST(1));
	    path = (const gchar *)SvPV_nolen (ST(1))
;
	}
#line 678 "xs\\\\GtkTreeModel.xs"
	PERL_UNUSED_VAR (ix);
	if (path)
		RETVAL = gtk_tree_path_new_from_string (path);
	else
		RETVAL = gtk_tree_path_new ();
#line 628 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreePath_own_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_new_from_indices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_new_from_indices)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "class, first_index, ...");
    {
#line 701 "xs\\\\GtkTreeModel.xs"
	gint i;
	GtkTreePath *path;
#line 646 "xs\\GtkTreeModel.c"
	GtkTreePath_own_ornull *	RETVAL;
#line 704 "xs\\\\GtkTreeModel.xs"
	path = gtk_tree_path_new ();

	for (i = 1 ; i < items ; i++) {
		gint index = SvIV (ST (i));
		if (index < 0)
			croak ("Gtk2::TreePath->new_from_indices takes index"
			       " values from the argument stack and therefore"
			       " does not use a -1 terminator value like its"
			       " C counterpart; negative index values are"
			       " not allowed");
		gtk_tree_path_append_index (path, index);
	}

	RETVAL = path;
#line 663 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreePath_own_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gchar_own *	RETVAL;

	RETVAL = gtk_tree_path_to_string(path);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_new_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_new_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "class");
    {
	GtkTreePath_own *	RETVAL;

	RETVAL = gtk_tree_path_new_first(/* void */);
	ST(0) = newSVGtkTreePath_own (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_append_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_append_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, index_");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gint	index_ = (gint)SvIV(ST(1))
;

	gtk_tree_path_append_index(path, index_);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreePath_prepend_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_prepend_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, index_");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gint	index_ = (gint)SvIV(ST(1))
;

	gtk_tree_path_prepend_index(path, index_);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreePath_get_depth); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_get_depth)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gint	RETVAL;
	dXSTARG;

	RETVAL = gtk_tree_path_get_depth(path);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_get_indices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_get_indices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
#line 754 "xs\\\\GtkTreeModel.xs"
	gint * indices;
	gint depth;
	gint i;
#line 782 "xs\\GtkTreeModel.c"
#line 758 "xs\\\\GtkTreeModel.xs"
	depth = gtk_tree_path_get_depth (path);
	indices = gtk_tree_path_get_indices (path);
	EXTEND (SP, depth);
	for (i = 0 ; i < depth ; i++)
		PUSHs (sv_2mortal (newSViv (indices[i])));
#line 789 "xs\\GtkTreeModel.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Gtk2__TreePath_compare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_compare)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	GtkTreePath *	a = SvGtkTreePath (ST(0))
;
	GtkTreePath *	b = SvGtkTreePath (ST(1))
;
	gint	RETVAL;
	dXSTARG;

	RETVAL = gtk_tree_path_compare(a, b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;

	gtk_tree_path_next(path);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreePath_prev); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_prev)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_path_prev(path);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_up); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_up)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_path_up(path);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_down); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_down)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;

	gtk_tree_path_down(path);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreePath_is_ancestor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_is_ancestor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, descendant");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	GtkTreePath *	descendant = SvGtkTreePath (ST(1))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_path_is_ancestor(path, descendant);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreePath_is_descendant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreePath_is_descendant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, ancestor");
    {
	GtkTreePath *	path = SvGtkTreePath (ST(0))
;
	GtkTreePath *	ancestor = SvGtkTreePath (ST(1))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_path_is_descendant(path, ancestor);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef GTK_TYPE_TREE_ROW_REFERENCE
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Gtk2__TreeRowReference_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeRowReference_new)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "class, model, path");
    {
	GtkTreeRowReference_own_ornull *	RETVAL;
	GtkTreeModel *	model = SvGtkTreeModel (ST(1))
;
	GtkTreePath *	path = SvGtkTreePath (ST(2))
;

	RETVAL = gtk_tree_row_reference_new(model, path);
	ST(0) = newSVGtkTreeRowReference_own_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeRowReference_get_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeRowReference_get_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	GtkTreePath_own_ornull *	RETVAL;
	GtkTreeRowReference *	reference = SvGtkTreeRowReference (ST(0))
;

	RETVAL = gtk_tree_row_reference_get_path(reference);
	ST(0) = newSVGtkTreePath_own_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeRowReference_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeRowReference_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	GtkTreeRowReference *	reference = SvGtkTreeRowReference (ST(0))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_row_reference_valid(reference);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#if GTK_CHECK_VERSION (2, 8, 0)
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_Gtk2__TreeRowReference_get_model); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeRowReference_get_model)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	GtkTreeModel_ornull *	RETVAL;
	GtkTreeRowReference *	reference = SvGtkTreeRowReference (ST(0))
;

	RETVAL = gtk_tree_row_reference_get_model(reference);
	ST(0) = newSVGtkTreeModel_ornull (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#endif /* defined GTK_TYPE_TREE_ROW_REFERENCE */

XS_EUPXS(XS_Gtk2__TreeIter_to_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeIter_to_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "iter, stamp");
    {
	SV *	RETVAL;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(0))
;
	IV	stamp = (IV)SvIV(ST(1))
;
#line 929 "xs\\\\GtkTreeModel.xs"
	if (iter->stamp != stamp)
		croak ("invalid iter -- stamp %d does not match "
		       "requested %" IVdf,
		       iter->stamp, stamp);
        RETVAL = sv_from_iter (iter);
#line 1033 "xs\\GtkTreeModel.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeIter_new_from_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeIter_new_from_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, sv_iter");
    {
#line 948 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter = {0, };
#line 1050 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
	SV *	sv_iter = ST(1)
;
#line 950 "xs\\\\GtkTreeModel.xs"
	if (!iter_from_sv (&iter, sv_iter))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1058 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeIter_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeIter_set)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "iter, from");
    {
	GtkTreeIter *	iter = SvGtkTreeIter (ST(0))
;
	SV *	from = ST(1)
;
#line 979 "xs\\\\GtkTreeModel.xs"
	if (gperl_sv_is_array_ref (from)) {
		iter_from_sv (iter, from);
	} else {
		GtkTreeIter *from_iter = SvGtkTreeIter (from);
		memcpy (iter, from_iter, sizeof(*iter));
	}
#line 1084 "xs\\GtkTreeModel.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_get_flags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_flags)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tree_model");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeModelFlags	RETVAL;

	RETVAL = gtk_tree_model_get_flags(tree_model);
	ST(0) = newSVGtkTreeModelFlags (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get_n_columns); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_n_columns)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tree_model");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	gint	RETVAL;
	dXSTARG;

	RETVAL = gtk_tree_model_get_n_columns(tree_model);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get_column_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_column_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, index_");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	gint	index_ = (gint)SvIV(ST(1))
;
#line 1017 "xs\\\\GtkTreeModel.xs"
	GType t;
#line 1141 "xs\\GtkTreeModel.c"
	const gchar *	RETVAL;
#line 1019 "xs\\\\GtkTreeModel.xs"
	t = gtk_tree_model_get_column_type (tree_model, index_);
	RETVAL = gperl_package_from_type (t);
	if (!RETVAL)
		croak ("internal -- type of column %d, %s (%d), is not registered with GPerl",
			index_, g_type_name (t), t);
#line 1149 "xs\\GtkTreeModel.c"
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get_iter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_iter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, path");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;
#line 1036 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter = {0, };
#line 1172 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
#line 1038 "xs\\\\GtkTreeModel.xs"
	if (!gtk_tree_model_get_iter (tree_model, &iter, path))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1178 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get_iter_from_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_iter_from_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, path_string");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	const gchar *	path_string;
#line 1058 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter = {0, };
#line 1198 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	path_string = (const gchar *)SvPV_nolen (ST(1))
;
#line 1060 "xs\\\\GtkTreeModel.xs"
	if (!gtk_tree_model_get_iter_from_string (tree_model, &iter, path_string))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1209 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#if GTK_CHECK_VERSION(2,2,0)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_Gtk2__TreeModel_get_string_from_iter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_string_from_iter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;
	gchar_own *	RETVAL;

	RETVAL = gtk_tree_model_get_string_from_iter(tree_model, iter);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);
    }
    XSRETURN(1);
}

#endif /* 2.2.0 */

XS_EUPXS(XS_Gtk2__TreeModel_get_iter_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_iter_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "tree_model");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
#line 1090 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter = {0, };
#line 1258 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
#line 1092 "xs\\\\GtkTreeModel.xs"
	if (!gtk_tree_model_get_iter_first (tree_model, &iter))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1264 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;
	GtkTreePath_own *	RETVAL;

	RETVAL = gtk_tree_model_get_path(tree_model, iter);
	ST(0) = newSVGtkTreePath_own (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_get)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2)
       croak_xs_usage(cv,  "tree_model, iter, ...");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;
#line 1136 "xs\\\\GtkTreeModel.xs"
	int i;
#line 1307 "xs\\GtkTreeModel.c"
#line 1138 "xs\\\\GtkTreeModel.xs"
	/* we use CODE: instead of PPCODE: so we can handle the stack
	 * ourselves. */
	PERL_UNUSED_VAR (ix);
#define OFFSET 2
	if (items > OFFSET) {
		/* if column id's were passed, just return those columns */

		/* the stack is big enough already due to the input arguments,
		 * so we don't need to extend it.  nor do we need to care about
		 * xsubs called by gtk_tree_model_get_value overwriting the
		 * stuff we put on the stack. */
		for (i = OFFSET ; i < items ; i++) {
			GValue gvalue = {0, };
			gtk_tree_model_get_value (tree_model, iter,
			                          SvIV (ST (i)), &gvalue);
			ST (i - OFFSET) = sv_2mortal (gperl_sv_from_value (&gvalue));
			g_value_unset (&gvalue);
		}
		XSRETURN (items - OFFSET);
	}
#undef OFFSET

	else {
		/* otherwise return all of the columns */

		int n_columns = gtk_tree_model_get_n_columns (tree_model);
		/* extend the stack so it can handle 'n_columns' items in
		 * total.  the stack already contains 'items' elements so make
		 * room for 'n_columns - items' more, move our local stack
		 * pointer forward to the new end, and update the global stack
		 * pointer.  this way, xsubs called by gtk_tree_model_get_value
		 * don't overwrite what we put on the stack. */
		SPAGAIN;
		EXTEND (SP, n_columns - items);
		SP += n_columns - items;
		PUTBACK;
		for (i = 0; i < n_columns; i++) {
			GValue gvalue = {0, };
			gtk_tree_model_get_value (tree_model, iter,
			                          i, &gvalue);
			ST (i) = sv_2mortal (gperl_sv_from_value (&gvalue));
			g_value_unset (&gvalue);
		}
		XSRETURN (n_columns);
	}
#line 1354 "xs\\GtkTreeModel.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_next)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;
	GtkTreeIter_own *	RETVAL;
#line 1200 "xs\\\\GtkTreeModel.xs"
	/* the C version modifies the iter we pass; to make this fit more
	 * with the rest of our Perl interface, we want *not* to modify
	 * the one passed and instead return the modified iter... which
	 * means we have to copy *first*. */
	RETVAL = gtk_tree_iter_copy (iter);
	if (!gtk_tree_model_iter_next (tree_model, RETVAL)) {
		gtk_tree_iter_free (RETVAL);
		XSRETURN_UNDEF;
	}
#line 1382 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_own (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_children); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_children)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, parent");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter_ornull *	parent = SvGtkTreeIter_ornull (ST(1))
;
#line 1223 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter;
#line 1403 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
#line 1225 "xs\\\\GtkTreeModel.xs"
	if (!gtk_tree_model_iter_children (tree_model, &iter, parent))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1409 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_has_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_has_child)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;
	gboolean	RETVAL;

	RETVAL = gtk_tree_model_iter_has_child(tree_model, iter);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_n_children); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_n_children)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "tree_model, iter=NULL");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter_ornull *	iter;
	gint	RETVAL;
	dXSTARG;

	if (items < 2)
	    iter = NULL;
	else {
	    iter = SvGtkTreeIter_ornull (ST(1))
;
	}

	RETVAL = gtk_tree_model_iter_n_children(tree_model, iter);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_nth_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_nth_child)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "tree_model, parent, n");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter_ornull *	parent = SvGtkTreeIter_ornull (ST(1))
;
	gint	n = (gint)SvIV(ST(2))
;
#line 1261 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter;
#line 1480 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
#line 1263 "xs\\\\GtkTreeModel.xs"
	if (!gtk_tree_model_iter_nth_child (tree_model, &iter, parent, n))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1486 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_iter_parent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_iter_parent)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, child");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	child = SvGtkTreeIter (ST(1))
;
#line 1279 "xs\\\\GtkTreeModel.xs"
	GtkTreeIter iter;
#line 1507 "xs\\GtkTreeModel.c"
	GtkTreeIter_copy *	RETVAL;
#line 1281 "xs\\\\GtkTreeModel.xs"
	if (! gtk_tree_model_iter_parent (tree_model, &iter, child))
		XSRETURN_UNDEF;
	RETVAL = &iter;
#line 1513 "xs\\GtkTreeModel.c"
	ST(0) = newSVGtkTreeIter_copy (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__TreeModel_ref_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_ref_node)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;

	gtk_tree_model_ref_node(tree_model, iter);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_unref_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_unref_node)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(1))
;

	gtk_tree_model_unref_node(tree_model, iter);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_foreach); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_foreach)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "model, func, user_data=NULL");
    {
	GtkTreeModel *	model = SvGtkTreeModel (ST(0))
;
	SV *	func = ST(1)
;
	SV *	user_data;
#line 1337 "xs\\\\GtkTreeModel.xs"
	GPerlCallback * callback;
	GType types[3];
#line 1572 "xs\\GtkTreeModel.c"

	if (items < 3)
	    user_data = NULL;
	else {
	    user_data = ST(2)
;
	}
#line 1340 "xs\\\\GtkTreeModel.xs"
	types[0] = GTK_TYPE_TREE_MODEL;
	types[1] = GTK_TYPE_TREE_PATH;
	types[2] = GTK_TYPE_TREE_ITER;
	callback = gperl_callback_new (func, user_data, G_N_ELEMENTS (types), types,
	                               G_TYPE_BOOLEAN);
	gtk_tree_model_foreach (model, gtk2perl_tree_model_foreach_func, callback);
	gperl_callback_destroy (callback);
#line 1588 "xs\\GtkTreeModel.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_row_changed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_row_changed)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "tree_model, path, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(2))
;

	gtk_tree_model_row_changed(tree_model, path, iter);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_row_inserted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_row_inserted)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "tree_model, path, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(2))
;

	gtk_tree_model_row_inserted(tree_model, path, iter);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_row_has_child_toggled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_row_has_child_toggled)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "tree_model, path, iter");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;
	GtkTreeIter *	iter = SvGtkTreeIter (ST(2))
;

	gtk_tree_model_row_has_child_toggled(tree_model, path, iter);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_row_deleted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_row_deleted)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "tree_model, path");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;

	gtk_tree_model_row_deleted(tree_model, path);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__TreeModel_rows_reordered); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__TreeModel_rows_reordered)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "tree_model, path, iter, ...");
    {
	GtkTreeModel *	tree_model = SvGtkTreeModel (ST(0))
;
	GtkTreePath *	path = SvGtkTreePath (ST(1))
;
	GtkTreeIter_ornull *	iter = SvGtkTreeIter_ornull (ST(2))
;
#line 1406 "xs\\\\GtkTreeModel.xs"
	gint *new_order;
	int n, i;
#line 1688 "xs\\GtkTreeModel.c"
#line 1409 "xs\\\\GtkTreeModel.xs"
	n = gtk_tree_model_iter_n_children (tree_model, iter);
	if (items - 3 != n)
		croak ("rows_reordered expects a list of as many indices"
		       " as the selected node of the model has children\n"
		       "   got %d, expected %d", (int) (items - 3), n);
	new_order = g_new (gint, n);
	for (i = 0 ; i < n ; i++)
		new_order[i] = SvIV (ST (3+i));
	gtk_tree_model_rows_reordered (tree_model, path, iter, new_order);
	g_free (new_order);
#line 1700 "xs\\GtkTreeModel.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Gtk2__TreeModel); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Gtk2__TreeModel)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("Gtk2::TreeModel::_ADD_INTERFACE", XS_Gtk2__TreeModel__ADD_INTERFACE, file);
        cv = newXS("Gtk2::TreePath::new", XS_Gtk2__TreePath_new, file);
        XSANY.any_i32 = 0;
        cv = newXS("Gtk2::TreePath::new_from_string", XS_Gtk2__TreePath_new, file);
        XSANY.any_i32 = 1;
        newXS("Gtk2::TreePath::new_from_indices", XS_Gtk2__TreePath_new_from_indices, file);
        newXS("Gtk2::TreePath::to_string", XS_Gtk2__TreePath_to_string, file);
        newXS("Gtk2::TreePath::new_first", XS_Gtk2__TreePath_new_first, file);
        newXS("Gtk2::TreePath::append_index", XS_Gtk2__TreePath_append_index, file);
        newXS("Gtk2::TreePath::prepend_index", XS_Gtk2__TreePath_prepend_index, file);
        newXS("Gtk2::TreePath::get_depth", XS_Gtk2__TreePath_get_depth, file);
        newXS("Gtk2::TreePath::get_indices", XS_Gtk2__TreePath_get_indices, file);
        newXS("Gtk2::TreePath::compare", XS_Gtk2__TreePath_compare, file);
        newXS("Gtk2::TreePath::next", XS_Gtk2__TreePath_next, file);
        newXS("Gtk2::TreePath::prev", XS_Gtk2__TreePath_prev, file);
        newXS("Gtk2::TreePath::up", XS_Gtk2__TreePath_up, file);
        newXS("Gtk2::TreePath::down", XS_Gtk2__TreePath_down, file);
        newXS("Gtk2::TreePath::is_ancestor", XS_Gtk2__TreePath_is_ancestor, file);
        newXS("Gtk2::TreePath::is_descendant", XS_Gtk2__TreePath_is_descendant, file);
#if XSubPPtmpAAAA
        newXS("Gtk2::TreeRowReference::new", XS_Gtk2__TreeRowReference_new, file);
        newXS("Gtk2::TreeRowReference::get_path", XS_Gtk2__TreeRowReference_get_path, file);
        newXS("Gtk2::TreeRowReference::valid", XS_Gtk2__TreeRowReference_valid, file);
#if XSubPPtmpAAAB
        newXS("Gtk2::TreeRowReference::get_model", XS_Gtk2__TreeRowReference_get_model, file);
#endif
#endif
        newXS("Gtk2::TreeIter::to_arrayref", XS_Gtk2__TreeIter_to_arrayref, file);
        newXS("Gtk2::TreeIter::new_from_arrayref", XS_Gtk2__TreeIter_new_from_arrayref, file);
        newXS("Gtk2::TreeIter::set", XS_Gtk2__TreeIter_set, file);
        newXS("Gtk2::TreeModel::get_flags", XS_Gtk2__TreeModel_get_flags, file);
        newXS("Gtk2::TreeModel::get_n_columns", XS_Gtk2__TreeModel_get_n_columns, file);
        newXS("Gtk2::TreeModel::get_column_type", XS_Gtk2__TreeModel_get_column_type, file);
        newXS("Gtk2::TreeModel::get_iter", XS_Gtk2__TreeModel_get_iter, file);
        newXS("Gtk2::TreeModel::get_iter_from_string", XS_Gtk2__TreeModel_get_iter_from_string, file);
#if XSubPPtmpAAAC
        newXS("Gtk2::TreeModel::get_string_from_iter", XS_Gtk2__TreeModel_get_string_from_iter, file);
#endif
        newXS("Gtk2::TreeModel::get_iter_first", XS_Gtk2__TreeModel_get_iter_first, file);
        newXS("Gtk2::TreeModel::get_path", XS_Gtk2__TreeModel_get_path, file);
        cv = newXS("Gtk2::TreeModel::get", XS_Gtk2__TreeModel_get, file);
        XSANY.any_i32 = 0;
        cv = newXS("Gtk2::TreeModel::get_value", XS_Gtk2__TreeModel_get, file);
        XSANY.any_i32 = 1;
        newXS("Gtk2::TreeModel::iter_next", XS_Gtk2__TreeModel_iter_next, file);
        newXS("Gtk2::TreeModel::iter_children", XS_Gtk2__TreeModel_iter_children, file);
        newXS("Gtk2::TreeModel::iter_has_child", XS_Gtk2__TreeModel_iter_has_child, file);
        newXS("Gtk2::TreeModel::iter_n_children", XS_Gtk2__TreeModel_iter_n_children, file);
        newXS("Gtk2::TreeModel::iter_nth_child", XS_Gtk2__TreeModel_iter_nth_child, file);
        newXS("Gtk2::TreeModel::iter_parent", XS_Gtk2__TreeModel_iter_parent, file);
        newXS("Gtk2::TreeModel::ref_node", XS_Gtk2__TreeModel_ref_node, file);
        newXS("Gtk2::TreeModel::unref_node", XS_Gtk2__TreeModel_unref_node, file);
        newXS("Gtk2::TreeModel::foreach", XS_Gtk2__TreeModel_foreach, file);
        newXS("Gtk2::TreeModel::row_changed", XS_Gtk2__TreeModel_row_changed, file);
        newXS("Gtk2::TreeModel::row_inserted", XS_Gtk2__TreeModel_row_inserted, file);
        newXS("Gtk2::TreeModel::row_has_child_toggled", XS_Gtk2__TreeModel_row_has_child_toggled, file);
        newXS("Gtk2::TreeModel::row_deleted", XS_Gtk2__TreeModel_row_deleted, file);
        newXS("Gtk2::TreeModel::rows_reordered", XS_Gtk2__TreeModel_rows_reordered, file);
    }

    /* Initialisation Section */

#if XSubPPtmpAAAA
#if XSubPPtmpAAAB
#endif
#endif
#line 990 "xs\\\\GtkTreeModel.xs"
	gperl_signal_set_marshaller_for (GTK_TYPE_TREE_MODEL, "rows_reordered",
	                                 gtk2perl_tree_model_rows_reordered_marshal);

#if XSubPPtmpAAAC
#endif
#line 1800 "xs\\GtkTreeModel.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

