/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of GtkBuildable.xs. Do not edit this file, edit GtkBuildable.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "xs\\\\GtkBuildable.xs"
/*
 * Copyright (c) 2007, 2010 by the gtk2-perl team (see the file AUTHORS)
 *
 * Licensed under the LGPL, see LICENSE file for more information.
 *
 * $Id$
 */

#include "gtk2perl.h"



/*
   Since perl already has a metric ton of XML parsers, Glib doesn't
   wrap GMarkupParser.  This is a miniature binding of just the bits
   of GMarkupParser that GtkBuildable needs.  The GMarkupParseContext
   is blessed as a Gtk2::Builder::ParseContext, and has only the
   user-usable methods bound.  (Should it happen that we need to bind
   GMarkupParseContext in Glib in the future, we can just move those
   methods to Glib, and have Gtk2::Builder::ParseContext inherit
   from Glib::Markup::ParseContext.)

   Builder doesn't use passthrough() and error(), but they were easy
   to implement and will be there if and when Builder does start to
   use them.
 */

static SV *
newSVGtkBuildableParseContext (GMarkupParseContext * context)
{
	return sv_setref_pv (newSV (0), "Gtk2::Buildable::ParseContext", context);
}

static GMarkupParseContext * 
SvGtkBuildableParseContext (SV * sv)
{
	if (! gperl_sv_is_defined (sv) || ! SvROK (sv))
		croak ("expected a blessed reference");

	if (! sv_derived_from (sv, "Gtk2::Buildable::ParseContext"))
		croak ("%s is not of type Gtk2::Buildable::ParseContext",
		       gperl_format_variable_for_output (sv));

	return INT2PTR (GMarkupParseContext *, SvIV (SvRV (sv)));
}



static SV *
check_parser (gpointer user_data)
{
	SV * sv = user_data;

	if (! gperl_sv_is_defined (sv) || ! SvROK (sv))
		croak ("parser object is not an object");

	return sv;
}

/*
 * Treat parser as an SV object, and call method on it in void context, with
 * the extra args from the va list.  You are expected to do any necessary
 * sv_2mortal() and such on those.  An exception will be converted to a GError.
 */
static void
call_parser_method (GError ** error,
		    gpointer parser,
		    GMarkupParseContext * context,
		    const char * method,
		    int n_args,
		    ...)
{
	va_list ap;
	dSP;

	ENTER;
	SAVETMPS;
	PUSHMARK (SP);

	EXTEND (SP, 2 + n_args);

	PUSHs (check_parser (parser));
	PUSHs (sv_2mortal (newSVGtkBuildableParseContext (context)));

	va_start (ap, n_args);
	while (n_args-- > 0) {
		SV * sv = va_arg (ap, SV *);
		PUSHs (sv);
	}
	va_end (ap);

	PUTBACK;

	call_method (method, G_VOID | G_DISCARD | G_EVAL);

	SPAGAIN;

	if (gperl_sv_is_defined (ERRSV) && SvTRUE (ERRSV)) {
		if (SvROK (ERRSV) && sv_derived_from (ERRSV, "Glib::Error")) {
			gperl_gerror_from_sv (ERRSV, error);
		} else {
                        /* g_error_new_literal() won't let us pass 0 for
                         * the domain... */
                        g_set_error (error, 0, 0, "%s", SvPV_nolen (ERRSV));
		}
	}

	FREETMPS;
	LEAVE;
}

/* Called for open tags <foo bar="baz"> */
static void
gtk2perl_buildable_parser_start_element (GMarkupParseContext *context,
					 const gchar         *element_name,
					 const gchar        **attribute_names,
					 const gchar        **attribute_values,
					 gpointer             user_data,
					 GError             **error)
{
	HV * hv;
	SV * attrs;
	int i;

	hv = newHV ();
	attrs = newRV_noinc ((SV *) hv);

	for (i = 0; attribute_names[i] != NULL ; i++)
		gperl_hv_take_sv (
			hv,
			attribute_names[i],
			strlen (attribute_names[i]),
			newSVGChar (attribute_values[i]));

	call_parser_method (error,
			    user_data,
			    context,
			    "START_ELEMENT",
			    2,
			    sv_2mortal (newSVGChar (element_name)),
			    sv_2mortal (attrs));
}

/* Called for close tags </foo> */
static void
gtk2perl_buildable_parser_end_element (GMarkupParseContext *context,
				       const gchar         *element_name,
				       gpointer             user_data,
				       GError             **error)
{
	call_parser_method (error,
			    user_data,
			    context,
			    "END_ELEMENT",
			    1,
			    sv_2mortal (newSVGChar (element_name)));
}

/* Called for character data */
/* text is not nul-terminated */
static void
gtk2perl_buildable_parser_text (GMarkupParseContext *context,
				const gchar         *text,
				gsize                text_len,  
				gpointer             user_data,
				GError             **error)
{
	SV * text_sv;

	text_sv = newSVpv (text, text_len);
	SvUTF8_on (text_sv);

	call_parser_method (error,
			    user_data,
			    context,
			    "TEXT",
			    1,
			    sv_2mortal (text_sv));
}

/* Called for strings that should be re-saved verbatim in this same
 * position, but are not otherwise interpretable.  At the moment
 * this includes comments and processing instructions.
 */
/* text is not nul-terminated. */
static void
gtk2perl_buildable_parser_passthrough (GMarkupParseContext *context,
				       const gchar         *passthrough_text,
				       gsize                text_len,  
				       gpointer             user_data,
				       GError             **error)
{
	SV * text_sv;

	text_sv = newSVpv (passthrough_text, text_len);
	SvUTF8_on (text_sv);

	call_parser_method (error,
			    user_data,
			    context,
			    "PASSTHROUGH",
			    1,
			    sv_2mortal (text_sv));
}

/* Called on error, including one set by other
 * methods in the vtable. The GError should not be freed.
 */
static void
gtk2perl_buildable_parser_error (GMarkupParseContext *context,
				 GError              *error,
				 gpointer             user_data)
{
	dSP;

	ENTER;
	SAVETMPS;
	PUSHMARK (SP);

	EXTEND (SP, 2);

	PUSHs (check_parser (user_data));
	PUSHs (sv_2mortal (newSVGtkBuildableParseContext (context)));
	PUSHs (sv_2mortal (gperl_sv_from_gerror (error)));

	PUTBACK;

	call_method ("ERROR", G_VOID | G_DISCARD);

	SPAGAIN;

	FREETMPS;
	LEAVE;

	PERL_UNUSED_VAR (context);
}

static const GMarkupParser mini_markup_parser = {
	gtk2perl_buildable_parser_start_element,
	gtk2perl_buildable_parser_end_element,
	gtk2perl_buildable_parser_text,
	gtk2perl_buildable_parser_passthrough,
	gtk2perl_buildable_parser_error
};



/*
 * Now, support for GtkBuildableIface.
 */

#define GET_METHOD(object, name) \
	HV * stash = gperl_object_stash_from_type (G_OBJECT_TYPE (object)); \
	GV * slot = gv_fetchmethod (stash, name);

#define METHOD_EXISTS  (slot && GvCV (slot))

#define GET_METHOD_OR_DIE(obj, name) \
	GET_METHOD (obj, name); \
	if (! METHOD_EXISTS) \
		die ("No implementation for %s::%s\n", \
		     gperl_package_from_type (G_OBJECT_TYPE (obj)), name);

#define PREP(obj) \
	dSP; \
	ENTER; \
	SAVETMPS; \
	PUSHMARK (SP) ; \
	PUSHs (sv_2mortal (newSVGObject (G_OBJECT (obj))));

#define CALL_VOID \
	PUTBACK; \
	call_sv ((SV *) GvCV (slot), G_VOID | G_DISCARD);

#define CALL_SCALAR(sv) \
	PUTBACK; \
	(void) call_sv ((SV *) GvCV (slot), G_SCALAR); \
	SPAGAIN; \
	sv = POPs; \
	PUTBACK;

#define FINISH \
	FREETMPS; \
	LEAVE;

static void          
gtk2perl_buildable_set_name (GtkBuildable  *buildable,
                             const gchar   *name)
{
	GET_METHOD (buildable, "SET_NAME");

	if (METHOD_EXISTS) {
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGChar (name)));
		CALL_VOID;
		FINISH;
	} else {
		/* Convenient fallback for mere mortals who need nothing
		   complicated.  This is the same as in the upstream
		   implementation. */
		g_object_set_data_full (G_OBJECT (buildable),
				        "gtk-builder-name",
					g_strdup (name),
					g_free);
	}
}

static const gchar * 
gtk2perl_buildable_get_name (GtkBuildable  *buildable)
{
	const gchar * name;

	GET_METHOD (buildable, "GET_NAME");

	if (METHOD_EXISTS) {
		SV * sv;

		PREP (buildable);
		CALL_SCALAR (sv);
		/*
		 * the interface wants us to return a const pointer, which
		 * means this needs to stay alive.  Unfortunately, we can't
		 * guarantee that the scalar will still be around by the
		 * time the string is used.  My first thought here was to
		 * use gperl_alloc_temp(), but that suffered the same
		 * lifetime issue, because the string was immediately
		 * returned to perl code, which meant that the temp was
		 * cleaned up an reused before the string was read.
		 * So, we'll go a little nuts and store a malloc'd copy
		 * of the string until the next call.  In theory, some
		 * code might be crazy enough to return a different name
		 * on the second call, so we won't bother with real caching.
		 */
		name = g_strdup (SvGChar (sv));
		g_object_set_data_full (G_OBJECT (buildable),
				        "gtk-perl-builder-name",
				        g_strdup (name),
					g_free);
		FINISH;

	} else {
		/* Convenient fallback for mere mortals who need nothing
		   complicated.  This is the same as in the upstream
		   implementation. */
		name = (const gchar *) g_object_get_data (G_OBJECT (buildable),
							  "gtk-builder-name");
	}

	return name;
}

static void          
gtk2perl_buildable_add_child (GtkBuildable  *buildable,
			      GtkBuilder    *builder,
			      GObject       *child,
			      const gchar   *type)
{
	GET_METHOD_OR_DIE (buildable, "ADD_CHILD");

	{
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGObject (child)));
		XPUSHs (sv_2mortal (newSVGChar (type)));
		CALL_VOID;
		FINISH;
	}
}

static void          
gtk2perl_buildable_set_buildable_property (GtkBuildable  *buildable,
					   GtkBuilder    *builder,
					   const gchar   *name,
					   const GValue  *value)
{
	GET_METHOD (buildable, "SET_BUILDABLE_PROPERTY");

	if (METHOD_EXISTS) {
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGChar (name)));
		XPUSHs (sv_2mortal (gperl_sv_from_value (value)));
		CALL_VOID;
		FINISH;
	} else
		g_object_set_property (G_OBJECT (buildable), name, value);
}

/* Nobody should really ever need this one; it's a special case for
 * GtkUIManager... but, just in case. */
static GObject *     
gtk2perl_buildable_construct_child (GtkBuildable  *buildable,
				    GtkBuilder    *builder,
				    const gchar   *name)
{
	GObject * child;

	GET_METHOD_OR_DIE (buildable, "CONSTRUCT_CHILD");

	{
		SV * sv;
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGChar (name)));
		CALL_SCALAR (sv);
		child = SvGObject (sv);
		FINISH;
	}

	return child;
}

static gboolean      
gtk2perl_buildable_custom_tag_start (GtkBuildable  *buildable,
				     GtkBuilder    *builder,
				     GObject       *child,
				     const gchar   *tagname,
				     GMarkupParser *parser,
				     gpointer      *data)
{
	gboolean ret = FALSE;

	GET_METHOD_OR_DIE (buildable, "CUSTOM_TAG_START");

	*data = NULL;
	memset (parser, 0, sizeof (*parser));

	{
		SV * sv;
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGObject (child)));
		XPUSHs (sv_2mortal (newSVGChar (tagname)));
		CALL_SCALAR (sv);
		if (gperl_sv_is_defined (sv)) {
			ret = TRUE;

			/* keep it...  we'll destroy it in custom-finished,
			 * below, regardless of whether the perl code
			 * actually does anything with it. */
			*data = newSVsv (sv);

			*parser = mini_markup_parser;
		}
		FINISH;
	}

	return ret;
}

static void          
gtk2perl_buildable_custom_tag_end (GtkBuildable  *buildable,
				   GtkBuilder    *builder,
				   GObject       *child,
				   const gchar   *tagname,
				   gpointer      *data)
{
	GET_METHOD (buildable, "CUSTOM_TAG_END");

	if (METHOD_EXISTS) {
		SV * parser = gperl_sv_is_defined ((SV *) data)
			    ? (SV *) data : &PL_sv_undef;
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGObject (child)));
		XPUSHs (sv_2mortal (newSVGChar (tagname)));
		XPUSHs (parser);
		CALL_VOID;
		FINISH;
	}
}

static void          
gtk2perl_buildable_custom_finished (GtkBuildable  *buildable,
				    GtkBuilder    *builder,
				    GObject       *child,
				    const gchar   *tagname,
				    gpointer       data)
{
	SV * parser = gperl_sv_is_defined ((SV *) data)
	            ? (SV *) data : &PL_sv_undef;

	GET_METHOD (buildable, "CUSTOM_FINISHED");

	if (METHOD_EXISTS) {
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGObject (child)));
		XPUSHs (sv_2mortal (newSVGChar (tagname)));
		XPUSHs (parser);
		CALL_VOID;
		FINISH;
	}

	if (parser != &PL_sv_undef)
		/* No further use for this. */
		SvREFCNT_dec (parser);
}

static void          
gtk2perl_buildable_parser_finished (GtkBuildable  *buildable,
				    GtkBuilder    *builder)
{
	GET_METHOD (buildable, "PARSER_FINISHED");

	if (METHOD_EXISTS) {
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		CALL_VOID;
		FINISH;
	}
}

static GObject *     
gtk2perl_buildable_get_internal_child (GtkBuildable  *buildable,
				       GtkBuilder    *builder,
				       const gchar   *childname)
{
	GObject * child = NULL;

	GET_METHOD (buildable, "GET_INTERNAL_CHILD");

	if (METHOD_EXISTS) {
		SV * sv;
		PREP (buildable);
		XPUSHs (sv_2mortal (newSVGtkBuilder (builder)));
		XPUSHs (sv_2mortal (newSVGChar (childname)));
		CALL_SCALAR (sv);
		child = SvGObject_ornull (sv);
		FINISH;
	}

	return child;
}


static void
gtk2perl_buildable_init (GtkBuildableIface * iface)
{
	iface->set_name = gtk2perl_buildable_set_name;
	iface->get_name = gtk2perl_buildable_get_name;
	iface->add_child = gtk2perl_buildable_add_child;
	iface->set_buildable_property = gtk2perl_buildable_set_buildable_property;
	iface->construct_child = gtk2perl_buildable_construct_child;
	iface->custom_tag_start = gtk2perl_buildable_custom_tag_start;
	iface->custom_tag_end = gtk2perl_buildable_custom_tag_end;
	iface->custom_finished = gtk2perl_buildable_custom_finished;
	iface->parser_finished = gtk2perl_buildable_parser_finished;
	iface->get_internal_child = gtk2perl_buildable_get_internal_child;
}



#line 564 "xs\\GtkBuildable.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 706 "xs\\GtkBuildable.c"

XS_EUPXS(XS_Gtk2__Buildable__ADD_INTERFACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable__ADD_INTERFACE)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, target_class");
    {
	const char *	target_class = (const char *)SvPV_nolen(ST(1))
;
#line 564 "xs\\\\GtkBuildable.xs"
    {
	static const GInterfaceInfo iface_info = {
		(GInterfaceInitFunc) gtk2perl_buildable_init,
		(GInterfaceFinalizeFunc) NULL,
		(gpointer) NULL
	};
	GType gtype = gperl_object_type_from_package (target_class);
	g_type_add_interface_static (gtype, GTK_TYPE_BUILDABLE, &iface_info);
    }
#line 727 "xs\\GtkBuildable.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Buildable_set_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_set_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "buildable, name");
    {
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	const gchar *	name;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	name = (const gchar *)SvPV_nolen (ST(1))
;

	gtk_buildable_set_name(buildable, name);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Buildable_get_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_get_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "buildable");
    {
	const gchar *	RETVAL;
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;

	RETVAL = gtk_buildable_get_name(buildable);
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Buildable_add_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_add_child)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "buildable, builder, child, type");
    {
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	GtkBuilder *	builder = SvGtkBuilder (ST(1))
;
	GObject *	child = SvGObject (ST(2))
;
	const gchar_ornull *	type;

	/* same as SvGChar(), but allows undef as NULL */
	if (gperl_sv_is_defined (ST(3))) {
		sv_utf8_upgrade (ST(3));
		type = (const gchar_ornull *)SvPV_nolen (ST(3));
	} else {
		type = NULL;
	}
;

	gtk_buildable_add_child(buildable, builder, child, type);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Buildable_set_buildable_property); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_set_buildable_property)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "buildable, builder, ...");
    {
#line 612 "xs\\\\GtkBuildable.xs"
	GValue value = {0,};
	int i;
#line 816 "xs\\GtkBuildable.c"
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	GtkBuilder *	builder = SvGtkBuilder (ST(1))
;
#line 615 "xs\\\\GtkBuildable.xs"
#define OFFSET 2
	if (0 != ((items - OFFSET) % 2))
		croak ("set_property expects name => value pairs "
		       "(odd number of arguments detected)");

	for (i = OFFSET; i < items; i += 2) {
		gchar *name = SvGChar (ST (i));
		SV *newval = ST (i + 1);

		GParamSpec *pspec =
			g_object_class_find_property (G_OBJECT_GET_CLASS (buildable),
						      name);

		if (!pspec) {
			const char *classname =
				gperl_object_package_from_type (G_OBJECT_TYPE (buildable));
			if (!classname)
				classname = G_OBJECT_TYPE_NAME (buildable);
			croak ("type %s does not support property '%s'",
			       classname, name);
		}

		g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));
		gperl_value_from_sv (&value, newval);
		gtk_buildable_set_buildable_property (buildable, builder, name, &value);
		g_value_unset (&value);
	}
#undef OFFSET
#line 850 "xs\\GtkBuildable.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Buildable_construct_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_construct_child)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "buildable, builder, name");
    {
	GObject_noinc *	RETVAL;
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	GtkBuilder *	builder = SvGtkBuilder (ST(1))
;
	const gchar *	name;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	name = (const gchar *)SvPV_nolen (ST(2))
;

	RETVAL = gtk_buildable_construct_child(buildable, builder, name);
	ST(0) = newSVGObject_noinc (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Buildable_parser_finished); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_parser_finished)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "buildable, builder");
    {
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	GtkBuilder *	builder = SvGtkBuilder (ST(1))
;

	gtk_buildable_parser_finished(buildable, builder);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Buildable_get_internal_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable_get_internal_child)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "buildable, builder, childname");
    {
	GObject *	RETVAL;
	GtkBuildable *	buildable = SvGtkBuildable (ST(0))
;
	GtkBuilder *	builder = SvGtkBuilder (ST(1))
;
	const gchar *	childname;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(2));
	childname = (const gchar *)SvPV_nolen (ST(2))
;

	RETVAL = gtk_buildable_get_internal_child(buildable, builder, childname);
	ST(0) = newSVGObject (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_element); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_element)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	const gchar *	RETVAL;
	SV *	sv = ST(0)
;

	RETVAL = g_markup_parse_context_get_element(SvGtkBuildableParseContext (sv));
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}

#if GLIB_CHECK_VERSION(2, 16, 0)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_element_stack); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_element_stack)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 710 "xs\\\\GtkBuildable.xs"
	const GSList * list;
#line 963 "xs\\GtkBuildable.c"
	SV *	sv = ST(0)
;
#line 712 "xs\\\\GtkBuildable.xs"
	list = g_markup_parse_context_get_element_stack
				(SvGtkBuildableParseContext (sv));
	while (list) {
		XPUSHs (sv_2mortal (newSVGChar (list->data)));
		list = list->next;
	}
#line 973 "xs\\GtkBuildable.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_position); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Buildable__ParseContext_get_position)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 728 "xs\\\\GtkBuildable.xs"
	int line_number;
	int char_number;
#line 993 "xs\\GtkBuildable.c"
	SV *	sv = ST(0)
;
#line 731 "xs\\\\GtkBuildable.xs"
	g_markup_parse_context_get_position (SvGtkBuildableParseContext (sv),
					     &line_number, &char_number);
	EXTEND (SP, 2);
	PUSHs (sv_2mortal (newSViv (line_number)));
	PUSHs (sv_2mortal (newSViv (char_number)));
#line 1002 "xs\\GtkBuildable.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Gtk2__Buildable); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Gtk2__Buildable)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Gtk2::Buildable::_ADD_INTERFACE", XS_Gtk2__Buildable__ADD_INTERFACE, file);
        newXS("Gtk2::Buildable::set_name", XS_Gtk2__Buildable_set_name, file);
        newXS("Gtk2::Buildable::get_name", XS_Gtk2__Buildable_get_name, file);
        newXS("Gtk2::Buildable::add_child", XS_Gtk2__Buildable_add_child, file);
        newXS("Gtk2::Buildable::set_buildable_property", XS_Gtk2__Buildable_set_buildable_property, file);
        newXS("Gtk2::Buildable::construct_child", XS_Gtk2__Buildable_construct_child, file);
        newXS("Gtk2::Buildable::parser_finished", XS_Gtk2__Buildable_parser_finished, file);
        newXS("Gtk2::Buildable::get_internal_child", XS_Gtk2__Buildable_get_internal_child, file);
        newXS("Gtk2::Buildable::ParseContext::get_element", XS_Gtk2__Buildable__ParseContext_get_element, file);
#if XSubPPtmpAAAA
        newXS("Gtk2::Buildable::ParseContext::get_element_stack", XS_Gtk2__Buildable__ParseContext_get_element_stack, file);
#endif
        newXS("Gtk2::Buildable::ParseContext::get_position", XS_Gtk2__Buildable__ParseContext_get_position, file);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 1046 "xs\\GtkBuildable.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

