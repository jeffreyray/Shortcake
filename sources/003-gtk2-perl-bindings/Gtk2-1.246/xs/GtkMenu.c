/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of GtkMenu.xs. Do not edit this file, edit GtkMenu.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "xs\\\\GtkMenu.xs"
/*
 * Copyright (c) 2003-2005, 2010 by the gtk2-perl team (see the file AUTHORS)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the 
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
 * Boston, MA  02111-1307  USA.
 *
 * $Id$
 */

#include "gtk2perl.h"
#include <gperl_marshal.h>


/*
 * yet another special case that isn't appropriate for either
 * GPerlClosure or GPerlCallback --- the menu position function has
 * mostly output parameters, so we need to change the callbacks's
 * signature for perl, getting multiple return values from the stack.
 * this one's easy, though.
 */

/* this is public so that other extensions which use GtkMenuPosFunc (e.g.
 * libgnomeui) don't need to reimplement it. */
void
gtk2perl_menu_position_func (GtkMenu * menu,
                             gint * x,
                             gint * y,
                             gboolean * push_in,
                             GPerlCallback * callback)
{
	int n;
	dGPERL_CALLBACK_MARSHAL_SP;

	GPERL_CALLBACK_MARSHAL_INIT (callback);

	ENTER;
	SAVETMPS;

	PUSHMARK (SP);

	EXTEND (SP, 3);
	PUSHs (sv_2mortal (newSVGtkMenu (menu)));
	PUSHs (sv_2mortal (newSViv (*x)));
	PUSHs (sv_2mortal (newSViv (*y)));
	if (callback->data)
		XPUSHs (sv_2mortal (newSVsv (callback->data)));

	/* A die() from callback->func is suspected to be bad or very bad.
	   Circa Gtk 2.18 a jump out of $menu->popup seems to leave an X
	   grab with no way to get rid of it (no keyboard Esc, and no mouse
	   click handlers).  The position func can also be called later for
	   things like resizing or move to a different GdkScreen, and such a
	   call might come straight from the main loop, where a die() would
	   jump out of Gtk2->main.  */

	PUTBACK;
	n = call_sv (callback->func, G_ARRAY | G_EVAL);
	SPAGAIN;

	if (SvTRUE (ERRSV)) {
		g_warning ("menu position callback ignoring error: %s",
			   SvPVutf8_nolen (ERRSV));
	} else if (n < 2 || n > 3) {
		g_warning ("menu position callback must return two integers "
			   "(x, and y) or two integers and a boolean "
			   "(x, y, and push_in)");
	} else {
		/* POPs and POPi take things off the *end* of the stack! */
		if (n > 2) {
			SV *sv = POPs;
			*push_in = sv_2bool (sv);
		}
		if (n > 1) *y = POPi;
		if (n > 0) *x = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
}

static GPerlCallback *
gtk2perl_menu_detach_func_create (SV *func, SV *data)
{
	GType param_types [2];
	param_types[0] = GTK_TYPE_WIDGET;
	param_types[1] = GTK_TYPE_MENU;
	return gperl_callback_new (func, data, G_N_ELEMENTS (param_types),
				   param_types, 0);
}

static void
gtk2perl_menu_detach_func (GtkWidget *attach_widget,
                           GtkMenu *menu)
{
	GPerlCallback *callback;

	callback = g_object_get_data (G_OBJECT (attach_widget),
	                              "__gtk2perl_menu_detach_func__");

	if (callback) {
		gperl_callback_invoke (callback, NULL, attach_widget, menu);

		/* free the handler after it's been called */
		g_object_set_data (G_OBJECT (attach_widget),
				   "__gtk2perl_menu_detach_func__", NULL);
	}
}

#line 132 "xs\\GtkMenu.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 274 "xs\\GtkMenu.c"

XS_EUPXS(XS_Gtk2__Menu_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "class");
    {
	GtkWidget *	RETVAL;

	RETVAL = gtk_menu_new(/* void */);
	ST(0) = newSVGtkWidget (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_popup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_popup)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "menu, parent_menu_shell, parent_menu_item, menu_pos_func, data, button, activate_time");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget_ornull *	parent_menu_shell = SvGtkWidget_ornull (ST(1))
;
	GtkWidget_ornull *	parent_menu_item = SvGtkWidget_ornull (ST(2))
;
	SV *	menu_pos_func = ST(3)
;
	SV *	data = ST(4)
;
	guint	button = (guint)SvUV(ST(5))
;
	guint	activate_time = (guint)SvUV(ST(6))
;
#line 156 "xs\\\\GtkMenu.xs"
	if (!gperl_sv_is_defined (menu_pos_func)) {
		gtk_menu_popup (menu, parent_menu_shell, parent_menu_item,
		                NULL, NULL, button, activate_time);
		g_object_set_data (G_OBJECT(menu), "_gtk2perl_menu_pos_callback", NULL);
	} else {
		GPerlCallback * callback;
		/* we don't need to worry about the callback arg types since
		 * we already have to marshall this callback ourselves. */
		callback = gperl_callback_new (menu_pos_func, data, 0, NULL, 0);
		gtk_menu_popup (menu, parent_menu_shell, parent_menu_item,
		        (GtkMenuPositionFunc) gtk2perl_menu_position_func,
			callback, button, activate_time);
		/* The menu will store the callback we give it, and can
		 * conceivably invoke the callback multiple times
		 * (repositioning, changing screens, etc).  Each call to
		 * gtk_menu_popup() replaces the function pointer.  So,
		 * if we use a weak reference, we can leak multiple callbacks;
		 * if we use object data, we can clean up the ones we install
		 * and reinstall.  Not likely, of course, but there are
		 * pathological programmers out there. */
		g_object_set_data_full (G_OBJECT (menu), "_gtk2perl_menu_pos_callback",
		                        callback,
		                        (GDestroyNotify)
		                             gperl_callback_destroy);
	}
#line 340 "xs\\GtkMenu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_reposition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_reposition)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	gtk_menu_reposition(menu);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_popdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_popdown)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	gtk_menu_popdown(menu);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_active); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_active)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget *	RETVAL;

	RETVAL = gtk_menu_get_active(menu);
	ST(0) = newSVGtkWidget (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_set_active); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_active)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, index");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	guint	index = (guint)SvUV(ST(1))
;

	gtk_menu_set_active(menu, index);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_set_accel_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_accel_group)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, accel_group");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkAccelGroup *	accel_group = SvGtkAccelGroup (ST(1))
;

	gtk_menu_set_accel_group(menu, accel_group);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_accel_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_accel_group)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkAccelGroup *	RETVAL;

	RETVAL = gtk_menu_get_accel_group(menu);
	ST(0) = newSVGtkAccelGroup (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_set_accel_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_accel_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, accel_path");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	const gchar *	accel_path;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	accel_path = (const gchar *)SvPV_nolen (ST(1))
;

	gtk_menu_set_accel_path(menu, accel_path);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_attach_to_widget); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_attach_to_widget)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "menu, attach_widget, detach_func");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget *	attach_widget = SvGtkWidget (ST(1))
;
	SV *	detach_func = ST(2)
;
#line 229 "xs\\\\GtkMenu.xs"
	GPerlCallback *callback;
#line 489 "xs\\GtkMenu.c"
#line 231 "xs\\\\GtkMenu.xs"
	callback = gtk2perl_menu_detach_func_create (detach_func, NULL);

	g_object_set_data_full (G_OBJECT (attach_widget),
	                        "__gtk2perl_menu_detach_func__",
			        callback,
	                        (GDestroyNotify) gperl_callback_destroy);

	gtk_menu_attach_to_widget (menu,
	                           attach_widget,
	                           gtk2perl_menu_detach_func);
#line 501 "xs\\GtkMenu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_detach); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_detach)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	gtk_menu_detach(menu);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_attach_widget); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_attach_widget)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget *	RETVAL;

	RETVAL = gtk_menu_get_attach_widget(menu);
	ST(0) = newSVGtkWidget (RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_set_tearoff_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_tearoff_state)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, torn_off");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	gboolean	torn_off = (bool)SvTRUE(ST(1))
;

	gtk_menu_set_tearoff_state(menu, torn_off);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_tearoff_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_tearoff_state)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	gboolean	RETVAL;

	RETVAL = gtk_menu_get_tearoff_state(menu);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_set_title); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_title)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, title");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	const gchar *	title;

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	title = (const gchar *)SvPV_nolen (ST(1))
;

	gtk_menu_set_title(menu, title);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_reorder_child); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_reorder_child)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "menu, child, position");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget *	child = SvGtkWidget (ST(1))
;
	gint	position = (gint)SvIV(ST(2))
;

	gtk_menu_reorder_child(menu, child, position);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_title); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_title)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	const gchar *	RETVAL;

	RETVAL = gtk_menu_get_title(menu);
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}

#if GTK_CHECK_VERSION(2,2,0)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Gtk2__Menu_set_screen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_screen)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, screen");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GdkScreen_ornull *	screen = SvGdkScreen_ornull (ST(1))
;

	gtk_menu_set_screen(menu, screen);
    }
    XSRETURN_EMPTY;
}

#endif
#if GTK_CHECK_VERSION(2,4,0)
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_Gtk2__Menu_attach); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_attach)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "menu, child, left_attach, right_attach, top_attach, bottom_attach");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	GtkWidget *	child = SvGtkWidget (ST(1))
;
	guint	left_attach = (guint)SvUV(ST(2))
;
	guint	right_attach = (guint)SvUV(ST(3))
;
	guint	top_attach = (guint)SvUV(ST(4))
;
	guint	bottom_attach = (guint)SvUV(ST(5))
;

	gtk_menu_attach(menu, child, left_attach, right_attach, top_attach, bottom_attach);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_set_monitor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_monitor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, monitor_num");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	gint	monitor_num = (gint)SvIV(ST(1))
;

	gtk_menu_set_monitor(menu, monitor_num);
    }
    XSRETURN_EMPTY;
}

#endif
#if GTK_CHECK_VERSION(2,6,0)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_Gtk2__Menu_get_for_attach_widget); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_for_attach_widget)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, widget");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GtkWidget *	widget = SvGtkWidget (ST(1))
;
#line 302 "xs\\\\GtkMenu.xs"
	GList *list, *i;
#line 728 "xs\\GtkMenu.c"
#line 304 "xs\\\\GtkMenu.xs"
	list = gtk_menu_get_for_attach_widget (widget);
	for (i = list; i; i = i->next)
		XPUSHs (sv_2mortal (newSVGtkMenu (i->data)));
#line 733 "xs\\GtkMenu.c"
	PUTBACK;
	return;
    }
}

#endif
#if GTK_CHECK_VERSION (2, 14, 0)
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_Gtk2__Menu_get_accel_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_accel_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	const gchar *	RETVAL;
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	RETVAL = gtk_menu_get_accel_path(menu);
	ST(0) = sv_newmortal();
	/* same as newSVGChar(), but not in a function */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Gtk2__Menu_get_monitor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_monitor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	gint	RETVAL;
	dXSTARG;
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	RETVAL = gtk_menu_get_monitor(menu);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* 2.14 */
#if GTK_CHECK_VERSION (2, 18, 0)
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_Gtk2__Menu_set_reserve_toggle_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_set_reserve_toggle_size)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "menu, reserve_toggle_size");
    {
	GtkMenu *	menu = SvGtkMenu (ST(0))
;
	gboolean	reserve_toggle_size = (bool)SvTRUE(ST(1))
;

	gtk_menu_set_reserve_toggle_size(menu, reserve_toggle_size);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Gtk2__Menu_get_reserve_toggle_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Gtk2__Menu_get_reserve_toggle_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "menu");
    {
	gboolean	RETVAL;
	GtkMenu *	menu = SvGtkMenu (ST(0))
;

	RETVAL = gtk_menu_get_reserve_toggle_size(menu);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Gtk2__Menu); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Gtk2__Menu)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Gtk2::Menu::new", XS_Gtk2__Menu_new, file);
        newXS("Gtk2::Menu::popup", XS_Gtk2__Menu_popup, file);
        newXS("Gtk2::Menu::reposition", XS_Gtk2__Menu_reposition, file);
        newXS("Gtk2::Menu::popdown", XS_Gtk2__Menu_popdown, file);
        newXS("Gtk2::Menu::get_active", XS_Gtk2__Menu_get_active, file);
        newXS("Gtk2::Menu::set_active", XS_Gtk2__Menu_set_active, file);
        newXS("Gtk2::Menu::set_accel_group", XS_Gtk2__Menu_set_accel_group, file);
        newXS("Gtk2::Menu::get_accel_group", XS_Gtk2__Menu_get_accel_group, file);
        newXS("Gtk2::Menu::set_accel_path", XS_Gtk2__Menu_set_accel_path, file);
        newXS("Gtk2::Menu::attach_to_widget", XS_Gtk2__Menu_attach_to_widget, file);
        newXS("Gtk2::Menu::detach", XS_Gtk2__Menu_detach, file);
        newXS("Gtk2::Menu::get_attach_widget", XS_Gtk2__Menu_get_attach_widget, file);
        newXS("Gtk2::Menu::set_tearoff_state", XS_Gtk2__Menu_set_tearoff_state, file);
        newXS("Gtk2::Menu::get_tearoff_state", XS_Gtk2__Menu_get_tearoff_state, file);
        newXS("Gtk2::Menu::set_title", XS_Gtk2__Menu_set_title, file);
        newXS("Gtk2::Menu::reorder_child", XS_Gtk2__Menu_reorder_child, file);
        newXS("Gtk2::Menu::get_title", XS_Gtk2__Menu_get_title, file);
#if XSubPPtmpAAAA
        newXS("Gtk2::Menu::set_screen", XS_Gtk2__Menu_set_screen, file);
#endif
#if XSubPPtmpAAAB
        newXS("Gtk2::Menu::attach", XS_Gtk2__Menu_attach, file);
        newXS("Gtk2::Menu::set_monitor", XS_Gtk2__Menu_set_monitor, file);
#endif
#if XSubPPtmpAAAC
        newXS("Gtk2::Menu::get_for_attach_widget", XS_Gtk2__Menu_get_for_attach_widget, file);
#endif
#if XSubPPtmpAAAD
        newXS("Gtk2::Menu::get_accel_path", XS_Gtk2__Menu_get_accel_path, file);
        newXS("Gtk2::Menu::get_monitor", XS_Gtk2__Menu_get_monitor, file);
#endif
#if XSubPPtmpAAAE
        newXS("Gtk2::Menu::set_reserve_toggle_size", XS_Gtk2__Menu_set_reserve_toggle_size, file);
        newXS("Gtk2::Menu::get_reserve_toggle_size", XS_Gtk2__Menu_get_reserve_toggle_size, file);
#endif

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#line 893 "xs\\GtkMenu.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

